# HTTP 완벽 가이드

# 1부 HTTP 웹의 기초

---

## 1장 HTTP 개관

- HTTP(Hypertext Transfer Protocol)
    - Hypertext → 참조를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트
    - Transfer → 전송
    - Protocol → 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계

    브라우저 상에서 데이터를 전달할 때 사용되는 통신 규약

### 1.1 HTTP: 인터넷의 멀티미디어 배달부

- HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용 → 정보가 손상된 게 아닌 지 염려할 필요 없음

### 1.2 웹 클라이언트와 서버

- 월드 와이드 웹의 기본 요소
    - 웹 서버(HTTP 서버) : 인터넷의 데이터를 저장하고 클라이언트에게 제공
    - HTTP 클라이언트: 웹 브라우저(ex 크롬, 익스플로러)
- 클라이언트는 서버에게 HTTP 요청을 보내고 서버는 요청된 데이터를 HTTP 응답으로 돌려줌

### 1.3 리소스

- 웹 서버는 웹 리소스를 관리하고 제공
- 웹 리소스란?
    - 웹 콘텐츠의 원천
    - 가장 단순한 웹 리소스 : 웹 서버 파일 시스템의 정적 파일(텍스트, HTML, JPEG ... 그 외 모든 종류의 파일)
    - 그러나 반드시 정적 파일일 필요는 없음 → 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수도 있음
        - ex) 카메라에서 라이브 영상을 가져와 보여주거나, 주식 거래, 부동산 데이터베이스 검색, 온라인 쇼핑몰에서 선물 구입을 할 수 있게 도와줄 수도 있음
        - 기업 판매 예측 스프레드 시트 파일이나 인터넷 검색 엔진

    1.3.1 미디어 타입

    - 인터넷은 수천가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 MIME 타입이라는 데이터 포맷 라벨을 붙임
    - MIME(Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)
        - 원래 각기 다른 전자 메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점 해결하기 위해 설계됨
        - 이메일에서 잘 동작했기 때문에, HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해 채택됨
    - 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙임 → 웹브라우저는 서버로부터 객체를 돌려받을 때, 다룰 수 있는 객체인지 MIME 타입을 통해 확인
    - 대부분의 웹 브라우저는 잘 알려진 객체 타입 수백 가지를 다룰 수 있음
    - MIME 타입은 사선(/)으로 구분된 주 타입(Primary object type)과 부 타입(specific subtype)으로 이루어진 문자열 라벨
        - HTML로 작성된 텍스트 문서 : text/html
        - plain ASCII 텍스트 문서 : text/plain
        - JEPG 이미지 : image/jpeg
        - GIF 이미지 : image/gif
        - 애플 퀵타임 동영상: video/quicktime
        - 마이크로소프트 파워포인트 프레젠테이션 : application/vnd.ms-powerpoint

    1.3.2 URI

    - 웹 서버 리소스는 각자 이름을 갖고 있기 때문에, 클라이언트는 관심 있는 리소스를 지목할 수 있음
    - 서버 리소스 이름은 통합 자원 식별자(uniform resource identifier) 혹은 URI로 불림
    - 인터넷의 우편물 주소 같은 것

        http://www.joes-hardware.com/specials/saw-blade.gif

        1. http → http 프로토콜을 사용하라
        2. [www.joes-hardware.com](http://www.joes-hardware.com) → 이곳으로 이동하라
        3. /specials/saw-blade.gif 라고 불리는 리소스를 가져와라

    URI에는 두가지가 있음( URL과 URN)

    1.3.2 URI

    - 통합 자원 지시자(uniform resource locator, URL) → 리소스 식별자의 가장 흔한 형태
    - 특정 서버의 한 리소스에 대한 구체적인 위치 서술
    - URL은 세 부분으로 이루어진 표준 포맷을 따름
        - URL의 첫번째 부분은 스킴(scheme)이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술. 보통 HTTP 프로토콜(http://)이다.
        - 두번째 부분은 서버의 인터넷 주소를 제공 (ex: www.joes-hardware.com)
        - 마지막은 웹 서버의 리소스를 가리킨다(ex: /specials/saw-blade.gif)

    1.3.2 URI

    - URI의 두번째 종류는 유니폼 리소스 이름(uniform resource name, URN)
    - 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 함
    - 위치 독립적이므로 리소스를 여기저기로 옮기더라도 문제없이 동작
    - 리소스가 그 이름을 변하지 않게 유지하는 한, 여러 종류의 네트워크 접속 프로토콜로 접근해도 문제없음
        - 인터넷 표준문서 RFC 2141에 대한 URN

        urn:ietf:rfc:2141

    - URN은 여전히 실험 중 → 리소스 위치를 분석하기 위한 인프라 지원이 부재
    - 하지만 전망이 밝음

    ### 1.4 트랜잭션

    HTTP 트랜잭션 → 요청 명령과 응답 결과로 구성되어 있음

    1.4.1 메서드

    [HTTP 메서드](https://www.notion.so/25452ffe1c0341a5adc6e8fc941a4f0b)

    1.4.2 상태코드

    - 모든 HTTP 응답 메시지는 상태 코드와 함께 반환됨
    - HTTP는 각 숫자 상태 코드에 텍스트로 된 "사유구절(reason phrase) 도 함께 보냄

    [HTTP 상태코드](https://www.notion.so/4c5c803c5da14f1594a5beabd5e7feb9)

    1.4.3 웹페이지는 여러 객체로 이루어질 수 있다

    - 애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행
        - 웹브라우저는 시각적으로 풍부한 웹페이지를 가져올 때 대량의 HTTP 트랜잭션을 수행
        - 페이지 레이아웃을 서술하는 HTML 뼈대를 한번의 트랜잭션으로 가져온 뒤, 첨부된 이미지, 그래픽 조각, 자바 애플릿 등을 가져오기 위해 추가로 HTTP 트랜잭션들을 수행

### 1.5 메시지

- HTTP 메시지는 단순한 줄 단위의 문자열 → 이진 형식이 아닌 일반 텍스트라 사람이 읽고 쓰기 쉽다
- 요청 메시지 : 웹 클라이언트에서 웹 서버로 보낸 HTTP 메시지
- 응답 메시지: 서버에서 클라이언트로 가는 메시지

시작줄

헤더

본문

요청 메시지

GET /test/hi-there.txt HTTP/1.0

---

Accept: text/*

Accept-Language: en,fr

---

응답 메시지

HTTP/1.0 200 OK

---

Content-type: text/plain

Content-length: 19

---

Hi! I'm a message!

- 시작줄
    - 메시지의 첫 줄은 시작줄
    - 요청이라면 무엇을 해야 하는지 응답이라면 무슨 일이 일어났는지 나타냄
- 헤더
    - 시작줄 다음에는 0개 이상의 헤더 필드가 이어짐
    - 각 헤더 필드는 쉬운 구문분석을 위해 쌍점(:)으로 구분되어 있는 하나의 이름과 하나의 값으로 구성
    - 헤더 필드를 추가하려면 그저 한 줄을 더하기만 하면 됨
    - 헤더는 빈 줄로 끝남
- 본문
    - 빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 올 수 있음
    - 요청의 본문은 웹 서버로 데이터를 실어 보내며, 응답의 본문은 클라이언트로 데이터를 반환
    - 문자열이며 구조적인 시작줄이나 헤더와 달리, 본문은 임의의 이진 데이터를 포함할 수 있음
    - 텍스트, 이미지, 비디오, 오디오 트랙, 응용 소프트웨어

1.5.1 간단한 메시지의 예

참고하면 좋을 것 같은 사진

### 1.6 TCP 커넥션

TCP(Transmission Control Protocol, 전송 제어 프로토콜)

- HTTP 메시지는 TCP 커넥션을 통해 한 곳에서 다른 곳으로 옮겨감

1.6.1 TCP/IP

- HTTP는 애플리케이션 계층 프로토콜이므로 네트워크 통신의 핵심적인 세부사항에 대해 신경쓰지 않음
- 대신 TCP/IP 에게 맡김
- TCP 가 제공하는 것
    - 오류 없는 데이터 전송
    - 순서에 맞는 전달 (데이터는 언제나 보낸 순서대로 도착한다)
    - 조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다)
- 인터넷은 TCP/IP에 기초하고 있음
- TCP/IP는 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합
    - 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해줌

HTTP 네트워크 프로토콜 스택

HTTP → 애플리케이션 계층

TCP → 전송 계층

IP → 네트워크 계층

네트워크를 위한 링크 인터페이스 → 데이터 링크 계층

물리적인 네트워크 하드웨어 → 물리 계층

1.6.2 접속, IP 주소 그리고 포트번호

- HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜(Internet Protocol, IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 함
- TCP 커넥션을 맺는 것은 다른 회사 사무실에 있는 누군가에게 전화를 거는 것과 비슷하다
    1. 먼저 회사의 전화번호를 누르고 회사와 연결
    2. 전화를 걸고자 하는 상대방이 쓰는 번호를 누름
- TCP에서는 서버 컴퓨터에 대한 IP 주소와 그 서버에서 실행중인 프로그램이 사용 중인 포트번호가 필요
- URL을 이용해 HTTP 서버의 IP 주소와 포트번호를 알아낼 수 있음
- 통신 과정
    1. 웹브라우저는 서버의 URL에서 호스트명을 추출
    2. 웹브라우저는 서버의 호스트 명을 IP로 변환
    3. 웹브라우저는 URL에서 포트번호(있다면)를 추출
    4. 웹브라우저는 웹 서버와 TCP 커넥션을 맺음
    5. 웹브라우저는 서버에 HTTP 요청을 보냄
    6. 서버는 웹 브라우저에 HTTP 응답을 돌려줌
    7. 커넥션이 닫히면, 웹브라우저는 문서를 보여줌

1.6.3 텔넷(Telnet)을 이용한 실제 예제

### 1.7 프로토콜 버전

- HTTP/0.9
    - 심각한 디자인 결함 있고, 구식 클라이언트하고만 사용 가능
    - GET 메서드만 지원
    - 멀티미디어 콘텐츠에 대한 MIME 타입이나, HTTP 헤더, 버전 번호는 지원하지 않음
- HTTP/1.0
    - 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가
    - 시각적으로 매력적인 웹페이지와 상호작용하는 폼을 실현 → 월드 와이드 웹을 대세로 만들었음
- HTTP/1.0+
    - 1990년대 중반, 월드 와이드 웹이 급격히 팽창하고 상업적으로도 성공하면서 여러 유명 웹 클라이언트와 서버들은 그에 따른 요구를 만족시키기 위해 발빠르게 HTTP에 기능 추가
    - 오래 지속되는 "keep-alive" 커넥션, 가상 호스팅 지원, 프락시 연결 지원
- HTTP/1.1
    - HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거
    - 더 복잡해진 웹 애플리케이션과 배포 지원
    - 현재의 HTTP 버전
- HTTP/2.0
    - 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜

### 1.8 웹의 구성요소

인터넷과 상호작용 할 수 있는 웹 애플리케이션의 종류

- 프락시 : 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 캐시 : 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
- 게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹 서버
- 터널 : 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 에이전트 : 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트

1.8.1 프락시

- 웹 보안, 애플리케이션 통합, 성능 최적화를 위한 중요한 구성요소
- 클라이언트와 서버 사이에 위치하여 클라이언트의 모든 HTTP 요청을 받아 서버에 전달(대개 요청을 수정한 뒤)
- 사용자를 대신해서 서버에 접근
- 주로 보안을 위해 사용됨
- 요청과 응답을 필터링
    - 회사에서 무엇인가를 다운 받을 때 애플리케이션 바이러스를 검출
    - 초등학교 학생들에게서 성인 콘텐츠를 차단

1.8.2 캐시

- 웹 캐시와 캐시 프락시 : 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, 특별한 종류의 HTTP 프락시 서버
    - 다음 번에 클라이언트가 같은 문서를 요청하면 그 캐시가 갖고 있는 사본을 받을 수 있음
- 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 문서를 다운 받을 수 있음
- HTTP는 캐시를 효율적으로 동작하게 하고 캐시된 콘텐츠를 최신 버전으로 유지하면서 동시에 프라이버시도 보호하기 위한 많은 기능을 정의

1.8.3 게이트웨이

- 다른 서버들의 중개자로 동작하는 특별한 서버
- 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됨
- 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룸 → 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아차리지 못함
- HTTP/FTP 게이트웨이는 FTP URI에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져옴 → 받아온 문서는 HTTP 메시지에 담겨 클라이언트에게 보냄

1.8.4 터널

- 두 커넥션 사이에서 날 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
- HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용됨
- HTTP 터널을 활용하는 대표적인 예
    - 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것
        1. 우선 HTTP/SSL 터널은 HTTP 요청을 받아들여 목적지의 주소와 포트번호로 커넥션을 맺음
        2. 이후부터는 암호화된 SSL 트래픽을 HTTP 채널을 통해 목적지 서버로 전송할 수 있게 됨

1.8.5 에이전트

- 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램
- 웹 요청을 만드는 애플리케이션은 뭐든 HTTP 에이전트
- 예시
    - 사람의 통제 없이 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 콘텐츠를 받아오는 자동화된 사용자 에이전트 (스파이더 or 웹로봇)
    - 스파이더는 웹을 돌아다니며, 검색엔진의 데이터베이스나 가격비교 로봇을 위한 제품 카탈로그와 같은 유용한 웹 콘텐츠 보관소를 만든다

## 2.1 인터넷의 리소스 탐색하기

- HTTP 명세에는 URI(하지만 대부분 URL)를 리소스 식별자로 이용하여 탐색
- URL(Uniform Resource Locator): 인터넷 리소스를 가리키는 표준 이름
    - '**스킴://서버위치/경로**' 의 구조로 이루어져 있음
        - 스킴: 웹 클라이언트가 리소스에 어떻게 접근하는지. 예: http 프로토콜 사용
        - 서버 위치: 리소스가 어디에 호스팅 되어있는지
        - 경로: 리소스의 경로로, 서버 내의 리소스 중 어느 리소스인지 판별

### 2.1.1 URL 이전의 암흑시대

- URL이 있기 전에는 애플리케이션마다 각자의 분류 방식 사용
- URL은 브라우저가 정보를 찾는데 필요한 모든 것을 제공하며, 어디에 위치하고 어떻게 가져오는지 정의함

## 2.2 URL 문법

- 대부분의 URL은 URL 문법을 따르며, 스킴에 따라 달라지기도 하지만 형태와 문법면에서 유사.

```
<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

- **스킴(scheme)**: 리소스를 가져오려면 어떤 프로토콜을 사용하여 서버에 접근해야하는가
- **사용자 이름(user name)**: 일부 스킴은 리소스에 접근하기 위해 사용자 이름 필요
    - 기본 값: anonymous
- **비밀번호(password)**: 사용자의 비밀번호
- **호스트(host)**: 리소스를 호스팅하는 서버의 호스트명이나 IP주소
- **포트(port)**: 리소스를 호스팅하는 서버가 열어 놓은 포트 번호. 많은 스킴이 기본 포트를 가지고 있음(HTTP는 80)
    - 기본 값: 스킴마다 다름.
- **경로(path)**: 서버 내 리소스가 서버에 어디에있는지 가리킴. 경로 컴포넌트의 문법은 서버와 스킴에 따라 다름. HTTP에서는 '/'문자를 기준으로 경로 조각으로 나눔(유닉스 파일 시스템과 유사)
- **파라미터(parameter)**: 특정 스킴(예: ftp)에서 정확한 요청을 위해 입력 파라미터를 기술하는 용도로 사용. 파라미터는 key/value 쌍을 가지며, 여러 쌍을 가질 수 있음.
    - 경로 조각마다 자체 파라미터를 가질 수 있다. 
    예: `http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true`
- **질의(query)**: 스킴에서 애플리케이션에 패러미터 전달용. 질의 컴포넌트 작성의 공통 포맷은 없음.
    - 편의상 많은 게이트웨이가 '&'로 나뉘는 'key=value' 형식의 질의 문자열을 원한다. 예: `...?item=12731&color=blue`
- **프래그먼트(fragment)**: 리소스를 본래 수준보다 더 작게 나누어, 조각이나 일부를 가리키는 이름. URL이 특정 객체를 가리킬 경우에 프래그먼트 필드는 서버에 전달되지 않고, 클라이언트에서만 사용.
    - 일반적으로 HTTP 서버는 객체 일부가 아닌 전체만 다루므로, 서버에 미전달하고 브라우저가 프래그먼트를 사용하여 보고자 하는 리소스만 보여줌

## 2.3 단축 URL

- URL의 종류: 상대 URL, 절대 URL
- 절대 URL은 우리가 지금까지 본 URL로, 리소스 접근에 필요한 모든 정보를 가지고 있음

### 2.3.1 상대 URL

- 상대 URL은 URL을 짧게 표기하는 방식으로, 리소스 접근에 필요한 모든 정보를 가지고 있지 않으며, 모든 정보를 얻기 위해서는 기저(base)라고 하는 다른 URL을 사용해야 한다.
- 상대 URL 문법에 따르면, HTML 작성자는 스킴, 호스트, 다른 컴포넌트를 입력하지 않아도 되며, 그 정보는 컴포넌트가 포함된 리소스의 기저 URL에서 추출 가능.
- 예시

    ```html
    <!-- http://www.joes-hardware.com/tools.html -->
    ...
    <p>
    ... selection of <a href=".hammers.html">hammers</a>on earth ...
    </p>
    ...
    ```

    - 위의 경우 기저 URL은: `http://www.joes-hardware.com/tools.html`
    - 이 기저 URL로 새로운 절대 URL 만들수 있다: `http://www.joes-hardware.com/hammers.html`
- 상대 URL을 사용하면 리소스 집합(html 페이지 등)을 쉽게 변경할 수 있고, 문서 집합의 위치를 변경하더라도 새로운 기저 URL에 의해 해석되기 때문에 정상적으로 동작한다.
- 상대 URL을 절대 URL로 변환하는 방법
    1. 기저  URL을 찾기
        - 리소스에서 명시적으로 제공 되거나 / 해당 리소스의 URL을 기저 URL로 사용하거나(앞의 예) / 기저 URL이 없는 경우(절대 URL이거나 깨진 URL)
    2. 상대 참조 해석하기
        - 기저 URL과, 상대 URL을 컴포넌트 단위로 분리하여 변환 알고리즘을 통해 절대 경로 형태로 변환한다.

### 2.3.2 URL 확장

어떤 브라우저는 URL입력시에 자동으로 URL을 확장하여 사용자가 URL을 빠르게 입력하도록 도와준다.

- 호스트명 확장
    - 단순한 휴리스틱만을 사용해서 입력한 홋스트명을 전체 호스트명으로 확장
    - 예: `yahoo` 입력 시, 자동으로 `www.yahoo.com` 으로 변환
- 히스토리 확장
    - 과거에 사용자가 방문했던 URL의 기록을 저장하여, URL 입력 시에 입력된 글자를 포함하는 방문한 완결된 형태의 URL중에서 선택하게 함.

## 2.4 안전하지 않은 문자

- 어떤 프로토콜을 통해서든 안전하게 전송 될 수 있도록 URL은 잘 호환되게 설계되었다.
- **안전한 문자**: 문자가 제거되어 정보가 유실되지 않도록 상대적으로 작고 안전한 알파벳 문자만 포함하도록 함
- **안전하지 않은 문자 제외**: 가독성을 위해 출력되지 않거나 보이지 않는 문자를 사용하는 것을 금지
- **이스케이프**: 이진 데이터나 알파벳 외의 문자도 포함할 수 있도록 안전하지 않은 문자를 안전한 문자로 인코딩

### 2.4.1 URL 문자 집합

- URL 문자 집합은 US-ASCII 문자 집합. 7비트를 사용하여 영자판 키와 출력되지 않는 제어문자 표현
    - US-ASCII는 오래된 문자 집합으로, 영어 외 유럽언어 및 비라틴계 언어를 지원하지 않음
- URL로 특정 이진 데이터를 포함해야 하는 경우 존재
- 이스케이프 문자열을 통해 특정 문자나 데이터를 인코딩할 수 있게 함

### 2.4.2 인코딩 체계

- [인코딩](https://en.wikipedia.org/wiki/Percent-encoding)은 안전하지 않은 문자를 퍼센티지 기호(%)로 시작해, ASCII 코드로 표현되는 두개의 16 진수로 이루어진 이스케이프 문자로 변환

### 2.4.3 문자 제한

- URL 내의 예약 문자로, 다른 목적으로 사용하려면 인코딩이 필요하다
    - `%` : 인코딩 된 문자에 사용할 이스케이프 토큰
    - `/` : 경로 컴포넌트에 있는 경로 세그먼트 나누는 용도
    - `.` : 경로 컴포넌트에서 선점
    - `..` : 경로 컴포넌트에서 선점
    - `#` : 프래그먼트 구획 문자
    - `?` : 질의 구획 문자
    - `;` : 파라미터 구획 문자
    - `:` : 스킴, 사용자이름/비밀번호, 호스트/포트의 구획 문자
    - `$`, `,`, `+` : 선점
    - `@`, `&`, `=` : 특정 스킴에서 특별한 의미가 있기때문에 선점
    - `{`, `}`, `|`, `\`, `~`, `[`, `]`, ` : 게이트웨이와 같은 여러 전송 에이전트에서 불안전하게 다룸
    - `<`, `>`, `"` : URL 범위 밖에서 역할이 있는 문자. 안전하지 않음.
    - `0x00` - `0x1F`, `0x7F`: 이 16진수 범위에 속하는 문자는 인쇄되지 않는 US-ASCII
    - `0x7F` < : 이 16진수 범위에 속하는 문자는 7비트 US-ASCII 가 아님

### 2.4.4 좀더 알아보기

- 입력받은 URL에서 어떤 문자를 인코딩해야 하는지는 사용자로부터 최초로 URL을 입력받는 애플리케이션(브라우저)에서 하는 것이 가장 적절
    - URL 구성 컴포넌트마다 사용 가능 문자가 다르며, 스킴에 따라서도 달라지므로
- 보통 URL을 해석하는 애플리케이션은 그것을 처리하기 전에 URL을 디코드해야 함

## 2.5 스킴의 바다

- **http**: 사용자 이름, 비밀번호가 제외된 일반 URL 포맷. 하이퍼 텍스트 전송 프로토콜(Hypertext Transfer Protocol)스킴. 기본 포트값은 80.

    ```
    http://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>
    http://www.joes-hardware.com/index.html
    ```

- **https**: http와 유사하며, HTTP 커넥션의 양 끝단에서 암호화 하기위해 보안 소켓 계층(Secure Sockets Layer, SSL)을 사용하는 점이 다름. 기본 포트값은 443.

    ```
    https://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>
    예: https://www.joes-hardware.com/secure.html
    ```

- **malito**: 이메일 주소를 가리키며, 다른 스킴과 다르게 동작하므로 표준 URL과 다른 포맷을 가진다. [RFC 882](https://tools.ietf.org/html/rfc822),  [RFC 2882](https://tools.ietf.org/html/rfc2822), [RFC 5332](https://tools.ietf.org/html/rfc5322)참조.

    ```
    mailto:<RFC-882-addr-spec>
    예: mailto:joe@joes-hardware.com
    ```

- **ftp**: 파일 전송 프로토콜(File Transfer Protocol)URL은 FTP서버에 있는 파일을 다운로드/업로드하고 디렉터리내의 콘텐츠 목록을 가져오는 데 사용.

    ```
    ftp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>
    예: ftp://anonymouse:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu
    ```

- **rtsp, rtspu**: 실시간 스트리밍 프로토콜(Real Time Streaming Protocol)을 통해서 읽을 수 있는 미디어 리소스(오디오 및 비디오 등) 식별자. rtsp**u**는 리소스를 읽기 위해 UDP 프로토콜을 사용됨을 뜻함

    ```
    rtsp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>
    rtspu://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>
    예: rtsp:www.joes-hardware.com:554/interview/cto_video
    ```

- **file**: 호스트 기기(로컬디스크, 네트워크 파일시스템, 기타 파일 공유 시스템)에서 바로 접근할 수 있는 파일을 나타냄. 일반적인 URL 포맷을 따르며, 호스트 생략시 URL을 사용하는 기기의 로컬호스트가 기본값

    ```
    file:<호스트>/<경로>
    예: file://OFFICE-FS/policies/casual-fridays.doc
    ```

- **news**: 특정 문서나 뉴스 그룹 접근용(RFC 1036). 해당 리소스 위치에 대한 정보를 포함하지 않으며 애플리케이션이 알아냄. 브라우저는 현재 설명되어있는 뉴스 서버 정보를 사용하여 어떤 서버로부터 뉴스를 가져올지 결정.

    ```
    news:<newsgroup>
    news:<news-article-id>
    예: news:rec.arts.startrek
    ```

- **telnet**: 대화형 서비스 접근용. telnet URL자체는 객체를 가리키지 않지만, 리소스라고 할 수 있는 대화형 애플리케이션이 telnet 프로토콜을 통해 접근 가능.

    ```
    telnet://<사용자이름>:<비밀번호>@<호스트>:<포트>/
    예: telnet:slurp:webhound@joes-hardware.com:23/
    ```


## 3.1 메시지의 흐름

- HTTP 메시지: HTTP 애플리케이션간에 주고 받은 데이터의 블록. 텍스트 메타 정보와 데이터(옵션)을 포함
    - 클라이언트, 서버, 프락시 사이를 흐름
- 트랜잭션의 방향
    - 인바운드/아웃바운드
        - 인바운드: 서버 방향
        - 아웃바운드: 사용자 에이전트 방향
    - 업스트림/다운스트림
        - 업스트림:  메세지의 발송자는 수신자의 업스트림
        - 다운스트림: 요청, 응답과 관계없이 모든 메세지는 다운스트림으로 흐름

## 3.2 메시지의 각 부분

- 메시지는 시작 줄(어떤 메시지인지), 헤더 블록(속성), 본문(데이터, 옵션)으로 이루어진다.

### 3.2.1 메시지 문법

- 요청과 응답은 모두 기본적으로 같은 구조이며, 시작 줄만 다르다

요청 메시지의 형식

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

응답 메시지

```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```

### 3.2.2 시작줄

***요청줄 / 응답줄***

- 모든 필드는 공백으로 구분

***요청 URL***

- 동작의 대상 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 컴포넌트.

***메서드***

- 클라이언트에서 서버가 리소스에 대해 수행해주길 바라는 동작.
- 공통 요청 메서드의 집합은 HTTP 명세에 정의되어있음
    - GET: 서버에서 어떤 문서를 가져온다. 본문 X
    - HEAD: 서버에서 어떤 문서에 대한 헤더만 가져온다.  본문 X
    - POST: 서버가 처리해야 할 데이터를 보낸다. 본문 O
    - PUT: 서버에 요청 메세지의 본문을 저장한다. 본문 O
    - TRACE: 메세지가 프락시를 거쳐 서버에 도달하는 과정 추적. 본문 X
    - OPTIONS: 서버가 어떤 메서드를 수행할 수 있는지 확인. 본문 X
    - DELETE: 서버에서 문서를 제거. 본문 X
- 모든 서버가 메서드 모두를 구현하지 않고, 서버가 오리지널 메소드를 만들었을 수도 있음(확장 메서드).

***상태코드***

- 클라이언트에게 요청 중에 무엇이 일어났는지 설명하는 세자리 숫자
- 상태 코드의 종류는 다음과 같으며, 범위보다 더 적은 수의 코드가 정의 되어있지만, 추후 확장될 가능성 있음
    - 100-199(실제 정의된 범위 100-101): 정보
    - 200-299(실제 정의된 범위 200-206): 성공
    - 300-399(실제 정의된 범위 300-305): 리다이렉션
    - 400-499(실제 정의된 범위 400-415): 클라이언트 에러
    - 500-599(실제 정의된 범위 500-505): 서버 에러
- 실제 정의된 범위 밖의 에러코드를 받는다면, 그 응답을 전체 범위내 코드로 간주해야 함
    - 예: 515를 받았다면 500대 서버 에러로 간주

***사유 구절(reason-phrase)***

- 상태 코드를 사람이 이해할 수 있도록 설명하는 문구로, 상태 코드와 1:1 대응.
- HTTP 명세 상에 사유 구절에 대한 엄격한 규칙은 없으므로, 사유 구절은 사람이 읽기 위한 목적으로만 사용하고 프로그래밍은 상태 코드를 기반으로 해야 함.

***버전 번호***

- 이 메시지에서 사용 중인 HTTP 버전. `HTTP/<메이저>.<마이너>` 형식을 따른다.
- 애플리케이션에게 해당 메시지의 형식과 가능한 능력에 대한 단서를 제공하기 위함

### 3.2.3 헤더

- 시작 줄 다음에 0+개의 해더가 오며, 헤더 필드는 기본적으로 key-value 쌍의 목록.
- 특정 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함되어야 유효.
- HTTP 헤더의 분류:
    - 일반 헤더: 요청, 응답 양쪽에 모두 나타날 수 있음
    - 요청 헤더: 요청에 대한 부가 정보를 제공
    - 응답헤더 : 응답에 대한 부가 정보를 제공
    - Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
    - 확장 헤더: 명세에 정의되지 않은 새로운 헤더
- HTTP 헤더의 문법
    - 이름, 쉼표, 공백(옶션), 필드값을 포함
    - 빈 줄(CRLF)로 끝나 엔터티 본문과 구분.
- HTTP 헤더의 예
    - `Data: Tue, 3 Octt 1997 02:16:03 GMT` : 서버가 응답을 만들어 낸 시각
    - `Content-length: 15040` : 15,040바이트의 데이터를 포함한 엔터티 본문
    - `Content-type: image/gif` : 엔터티 본문은 GIF 이미지이다
    - `Accept: image/gif, image/jpeg, tetxt/html` : 클라이언트는 GIF, JPEG, HTML을 받아들일 수 있다

***헤더를 여러 줄로 나누기***

- 긴 헤더 줄은 여러줄로 쪼개서 읽기 좋게 할 수 있음. 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야한다.

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
	Version 1.0 ← 쪼개진 헤더 
```

### 3.2.4 엔터티 본문

- 여러가지 종류의 데이터 블록을 포함하는 optional 값.

### 3.2.5 버전 0.9 메시지

- HTTP 프로토콜 초기 버전으로, 현재의 요청, 응답 메셋지의 시초지만 훨씬 단순한 프로토콜.
    - 요청: 메서드, 요청 URL
    - 응답: 엔터티
- 너무 단순하여 다양한 상황에 대응할 수 없고, 책에서 설명하는 기능 및 애플리케이션도 구현 불가능
    - 그럼에도 설명하는 것은 오래된 소프트웨어들이 계속 사용하기도 하기때문에 제약사항을 알아두기 위함

## 3.3 메서드

- HTTP 1.1 과 호환되려면 최소 GET, HEAD 메서드를 구현해야 함

### 3.3.1 안전한 메서드(Safe Method)

- GET, HEAD는 HTTP 요청의 결과로 서버에 어떤 작용도 없으므로 안전한 메서드
    - 의미상으로 안전한거지, 웹 개발자의 명세에 맞춰 개발하지 않는 경우 서버에 작용을 유발할 수도 있다.

[책 외 참고 링크(MDN)](https://developer.mozilla.org/en-US/docs/Glossary/safe)

### 3.3.2 GET

- 가장 흔히 쓰이는 메서드로, 서버에게 리소스를 달라고 요청하기 위해 사용

### 3.3.3 HEAD

- 정확히 GET처럼 행동하지만, 서버는 응답을 헤더만 돌려줌(엔터티 본문 X)
    - 서버 개발자들은 GET과 동일한 헤더를 돌려줌을 보장해야함.
- 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만 조사할 수 있도록 해줌
    - 리소스를 가져오지 않고 무엇인지(타입 등)을 알아낼 수 있음
    - 응답 상태 코드를 통해 개체 존재 유무 확인
    - 헤더 확인하여 리소스 변경여부 검사

### 3.3.4 PUT

- 서버에 문서를 작성.
    - 서버가 요청의 본문으로 요청 URL의 이름의 새 문서를 만들거나, 이미 존재한 URL이라면 본문을 교체
- PUT은 콘텐츠 변경을 할 수 있게 하므로, 많은 웹서버가 PUT을 수행 전 로그인을 요구

### 3.3.5 POST

- 서버에 입력데이터를 전송하기위해 사용.
    - POST는 서버에 데이터를 보내기위해. PUT은 서버의 리소스에 데이터를 입력하기 위해
- 실제로, HTML 폼 지원에 많이 사용되어, 폼 데이터를 서버에 전송

### 3.3.6 TRACE

- TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이는지 알려줌
    - 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과히며, 이들은 원래의 HTTP 요청을 수정할 수도 있음
- TRACE 요청은 목적지 서버에서 '**루프백(loopback)**' 진단을 시작
    - 서버는 자신이 받은 요청 메세지를 본문에 넣어 TRACE 응답을 되돌려 줌
    - 클라이언트는 자신과 서버 사이의 모든 HTTP 애플리케이션 요청/응답 연쇠를 따라가면서 망가지거나 수정되었는지, 그렇다면 어떻게 바뀌었는지 확인 가능
- TRACE는 주로 진단용으로 사용. 의도한 요청/응답 연쇄를 거쳐가는지 검사. 또는 다른 애플리케이션이 요청에 어떤 영향을 주는지 확인
- 많은 HTTP 애플리케이션은 메서드마다 다르게 동작하는데, TRACE는 메서드를 구별하는 메커니즘 미제공. TRACE 요청을 어떻게 처리할 것인지는 일반적으로 중간 애플리케이션이 결정.
- TRACE 요청은 엔터티 본문을 보낼 수 없다. TRACE 응답에는 서버가 받은 요청이 그대로 들어있다.

### 3.3.7 OPTIONS

- 웹 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지  지원 범위 문의.
- 실제로 여러 리소스에 대해 접근하지 않고도 어떻게 접근할 수 있는지 확인하는 수단으로 제공 됨

### 3.3.8 DELETE

- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청.
- HTTP 명세상 서버가 클라이언트에게 알리지않고 DELETE 요청을 무시할 수 있으므로, 삭제가 보장되지는 않음

### 3.3.9 확장메서드

- HTTP는 설계상 필요에 따라 확장해도 됨.
    - "엄격하게 보내고 관대하게 받아들여라" 라는 관용 규칙이 있음
- 대표적인 확장 메서드
    - LOCK: 사용자가 리소스를 잠글 수 있게 해줌. 예: 문서 동시 편집 방지
    - MKCOL: 사용자가 문서 생성할 수 있게 함.
    - COPY: 서버에 있는 리소스 복사
    - MOVE: 서버에 있는 리소스 옮기기
- 알려지지 않은 메서드가 요청으로 오면, 관용적으로 [501 Not Implemented](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/501) 상태코드로 응답해야함

## 3.4 상태 코드

### 3.4.1 100-199: 정보성 상태 코드

- HTTP/1.1 에서 도입.
- 상태 코드의 종류
    - [100 Continue](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/100): 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트가 나머지를 계속 보내야 함. 서버는 100 전송 후, 반드시 그 다음 요청을 받아 응답해야 함
    - [101 Switching Protocols](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/101): 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음

***클라이언트와 100 Continue***

- 엔터티 전송 예정, 그 전에 100 Continue 대기 → 100-continue를 값으로하는 Expect  요청 헤더 전송
    - 전송 이후 100 Continue 미 응답시 계속 기다리지말고, 타임아웃 후에 엔터티 전송 필요 (오래된 구현사항 대비용)
- 엔터티를 미전송 → 100-continue Expect 헤더 미전송
    - 전송시 엔터티를 보낼 것이라고 서버가 기대함

***서버와 100 Continue***

- 100-continue Expect 헤더 수신시 → 100 Continue 혹은 에러코드로 응답
    - 100 Continue 전송 전에 엔터티의 일부 혹은 전체를 수신하였다면 클라이언트는 계속 전송한다는 뜻으로, 서버는 100 Continue 를 전송할 필요가 없다
        - 하지만 요청을 다 읽은 후에 그 요청에 대한 최종 응답은 보내야한다(100 Continue 생략)
    - 본문 수신 전에 에러등의 이유로 요청을 끝내려고 할 때, 그냥 응답을 보내고 연결을 닫으면 안됨.
        - 클라이언트가 응답을 받을 수 없기 때문
- 100-continue Expect 헤더 미수신시 → 100 Continue  미전송

***프락시와 100 Continue***

- 클라이언트로부터 100-continue 응답을 의도한 요청을 받은 프락시는, 다음 홉(next-hop) 서버가
    - HTTP/1.1, 또는 버전을 모름 → Expect 헤더를 포함시켜 요청을 전달 필요.
    - HTTP/1.0과 그 이하 → 417 Expectation Faile 에러 응답
- 클라이언트가 HTTP/1.0과 그 이하일 때, 클라이언트 대신 Expect헤더와 100-continue를 요청에 포함한다면
    - 클라이언트가 응답할 줄 모르므로 서버의 100 Continue 응답을 클라이언트에 전달하지 않는다.

### 3.4.2 200-299: 성공 상태 코드

- 상태 코드의 종류
    - [200 OK](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/200): 요청이 정상, 엔터티 본문에 요청된 리소스 포함됨
    - [201 Created](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/201): 서버에 객체를 생성하는 요청(PUT 등)이 성공적으로 처리됨.
        - 서버는 상태 코드를 보내기전 반드시 객체를 생성하고, 생성된 리소스에 대한 구체적인 참조가 담긴 Location 헤더, 그 리소스를 참조할 수 있는 여러 URL을 본문에 포함해야함.
    - [202 Accepted:](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/202) 요청은 받아들여졌으나, 서버는 아직 어떤 동작도 수행하지 않음(수행보장 X).
        - 서버는 엔터티 본문에 요청에 대한 상태,  (가급적) 요청의 처리가 언제 완료되는지에 대한 정보를 포함해야 함
    - [203 Non-Authoritative Information](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/203): 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스 사본에서 옴. 중개자가 리소스 사본을 들고 있지만, 리소스에 대한 메타 정보(헤더를) 검증 못/안한 케이스. 엔터티 헤더가 원래 서버에서 온 것이였다면 200일 경우 였을 애플리케이션을 위한 선택사항
    - [204 No Content](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/204): 응답 메시지에 엔터티 본문이 없음. 주로 웹 브라우저를 새문서로 이동하지않고 갱신할 때 (예: 폼 리프레시)
    - [205 Reset Content](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/205): 주로 브라우저에게 사용되는 코드로, 현재 페이지에 있는 HTML 폼을 비우라고 알려줌
    - [206 Partial Content](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/206): 부분 혹은 범위 요청 성공. 클라이언트는 특별한 헤더를 사용해, 문서의 부분 혹은 특정 범위를 요청할 수 있음.
        - 서버는 Content-Rage와 Data 헤더를 반드시 포함해야함. Etag / Content-Location 중 하나의 헤더도 포함해야함.

### 3.4.3 300-399: 리다이렉션 상태 코드

- 해당 리소스에 대해 다른 위치를 사용하라고 하거나, 리소스 내용 대신 다른 응답 제공
    - 리다이렉션 상태코드와 선택적 Location 헤더를 보낼 수 있음
- 상태 코드 종류:
    - [300 Multiple Choices](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/300): 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 해당 리소스의 목록과 함께 반환(Location 헤더에 선호하는 URL 포함 가능). 유저는 목록중에 선택 가능. (예: 어떤 문서가 두 언어로 제공 등)
    - [301 Moved Permanetly](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/301): 요청한 URL이 옮겨졌음. 응답은 Locatiton 헤더에 현재 리소스가 존재하는 URL 포함
    - [302 Found](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/302): 301과 동일하지만, Location 헤더로 주어진 URL 리소스를 임시로 가리키기 위한 목적으로 사용. 이후 요청에서는 원래 URL 사용.
    - [303 See Other](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/303): 클라이언트에게 리소스를 다른 URL에서 가져와야한다고 전달 할때. 새 URL은 응답 메세지의 Location 헤더에 있음. 주로 POST 요청에 대한 응답으로 클라이언트에게 리소스 위치를 알려줄 때 사용
    - [304 Not Modified](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/304): 클라이언트 헤더를 이용해 조건부 요청을 .
        - 이상태 코드를 동반한 응답에는 엔터티 본문이 없어야 함
    - [305 Use Proxy](https://tools.ietf.org/html/rfc7231#section-6.4.5): 리소스를 반드시 프락시를 통해서 접근해야 함. 보안 이슈로 미사용.
    - [306 (Unused)](https://tools.ietf.org/html/rfc7231#section-6.4.6): HTTP 1.1 이전 스펙으로 현재 미사용.
    - [307 Temporary Redirect](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/307): 301 상태코드와 유사하나, 클라이언트는 Location 헤더로 주어진 URL 리소스를 임시로 가리키기 위한 목적으로 사용. 이후 요청에서는 원래 URL 사용.
- 302, 303, 307이 중복되는 부분이 있으며, 이 차이는 HTTP/1.0, HTTP/1.1 이 상태코드를 다루는 방식의 차이에서 기인
    - 1.0 클라이언트: POST 요청을 보내고 302를 받으면 클라이언트는 Location 헤더에 있는 리다이렉트 URL을 GET  요청으로 따라감
    - 1.0 서버: POST 요청을 받고 302를 보내면, 서버는 클라이언트가 리다이렉션 URL에 GET 요청으로 리다이렉트를 따라가기를 기대
    - 1.1 서버: 해당 케이스에는 뒤이어 GET 요청이 오도록 POST 요청을 리다이렉션하기 위해 303을 전송
        - 이 혼란을 막기 위해, 302는 HTTP 1.0에게 남겨두고 HTTP 1.1은 일시적인 리다이렉트로 307을 사용하도록 함
        - 307은 Method 와 Body 를 변경하지 않고 리다이렉트 요청을 하도록 보장. [출처](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/307)
    - 서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이렉트 상태 코드를 선택하기위해 클라이언트의 HTTP 버전을 검사할 필요가 있음

### 3.4.4 400-499: 클라이언트 에러 상태 코드

- 상태 코드 종류:
    - [400 Bad Request](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/400): 클라이언트가 잘못된 요청을 보냄
    - [401 Unauthorized](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/401): 리소스를 얻기전에 클라이언트가 인증이 필요함
    - [402 Payment Required](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/402): 사용될 것으로 예정하고 예약된 미사용 코드
    - [403 Forbbiden](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/403): 서버에 의해 요청 거부됨. 거부사유를 엔터티 본문에 포함할 수 있지만, 주로 이유를 숨기는 용도로 사용
    - [404 Not Found](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/404): 요청한 URL을 찾을 수 없음. 사용자에게 없음을 보여주기위한 엔터티가 포함되기도 함
    - [405 Method Not Allowed](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/405): 지원하지 않는 메서드. 어떤 메서드가 사용 가능한지 알려주기 위해 응답에 Allow 헤더가 포함되어야 함
    - [406 Not Acceptable](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/406): 클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자하는지를 매개변수로 명시할 수 있는데, 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우에 사용. 추가로 왜 요청이 만족될 수 없는지 알려주는 헤더를 포함할 수 있음.
    - [407 Proxy Authentication Required](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/407): 401과 같으나 리소스에 대해 인증을 요구하는 프락시 서버용
    - [408 Request Timeout](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/408): 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 코드를 반환하고 연결을 끊을 수 있음. 타임아웃의 길이는 서버마다 다르지만 대개 충분히 길다.
    - [409 Conflict](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/409): 요청이 리소스에 대해 충돌을 일으킬 염려가 있다고 생각될 때. 응답은 충돌에 대해 설명하는 본문을 포함
    - [410 Gone](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/410): 404와 유사하나, 한때 그 리소스를 가지고 있다는 점이 다름. 유지보수 시에 기존 리소스가 제거된 경우를 알려주기 위함
    - [411 Length Required](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/411): Content-Length 헤더를 요구할 때 사용
    - [412 Precondition Failed](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/412): 클라이언트의 조건부 요청 중 하나가 실패했을 때. 조건부 요청에는 Expect 헤더를 포함.
    - [413 Request Entity Too Large](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/413): 서버가 처리할 수 있는, 처리하고자 하는 한계를 넘은 크기의 요청
    - [414 Request URI Too Long](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/414): 서버가 처리할 수 있는, 처리하고자 하는 한계를 넘은 길이의 요청 URL
    - [415 Unsupported Media Type](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/415): 서버가 이해 하거나 지원하지 못하는 내용의 유형의 엔터티를 클라이언트가 보냈을 때
    - [416 Requested Range Not Satisfiable](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/416): 요청 메세지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못된 경우
    - [417 Expectation Failed](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/417): 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 있는 경우. 프락시나 다른 중개자 애플리케이션은 원 서버가 요청을 만족할 수 없다는 명확한 근거가있으면 이 응답 전송 가능.

### 3.4.5 500-599: 서버 에러 상태 코드

- 상태 코드 종류:
    - [500 Internal Server Error](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/500): 서버가 요청을 처리할 수 없게만드는 에러를 만났을 때
    - [501 Not Implemented](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/501): 클라이언트가 서버의 능력을 넘은 요청을 했을 때(예: 서버가 지원하지 않는 메서드 사용)
    - [502 Bad Gateway](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/502): 프락시나 게이트웨이처럼 행동하는 서버가 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때(예: 자신의 부모 게이트웨이에 접속하는 것이 불가능 할때)
    - [503 Service Unavailable](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/503):  현재는 서버가 요청을 처리해 줄수 없지만, 나중에 가능함을 의미. 언제 사용 가능할 수 있을지 알 수 있다면, 서버 Retry-After 헤더를 응답에 포함시킬 수 있다.
    - [504 Gateway Timeout](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/504): 408과 유사하지만, 요청은 서버로 보내고 타임아웃이 발생한 게이트웨이나 프락시에서 응답이 옴.
    - [505 HTTP Version Not Supported](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/505): 서버가 지원할 수 없거나, 지원하지 않으려고 하는 버전의 프로토콜로 요청을 받았을 때.

## 3.5 헤더

### 3.5.1 일반 헤더

- 아주 기본적인 정보를 제공하며 클라이언트와 서버 양쪽 모두 사용.
- 헤더 종류
    - Connection: 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 지정
    - Date: 메시지가 언제 만들어졌는지
    - MIME-Version: 발송자가 사용한 MIME 버전
    - Trailer chunked transfer: 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록
    - Transfer-Encoding: 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지
    - Upgrade: 발송자가 '업그레이드'하길 원하는 새 버전이나 프로토콜
    - Via: 이 메시지가 어떤 중개자(프락시, 게이트웨이)를 거쳐왔는지

***일반 캐시 헤더***

- 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 헤더.
    - Cache-Control: 메시지와 함께 캐시 지시자를 전달
    - Pragma: 메시지와 함께 지시자를 전달하는 또 다른 방법.

### 3.5.2 요청 헤더

- Client-IP: 클라이언트가 실행된 컴퓨터의 IP
- From: 클라이언트 사용자의 메일 주소
- Host: 요청 대상이 되는 서버의 호스트 명과 포트
- Referer: 현재 요청 URI가 들어있던 문서의 URL
- UA-Color: 클라이언트 기기 디스플레이의 색상 능력
- UA-CPU: 클라이언트 CPU 종료나 제주사
- UA-Disp: 클라이언트 디스플레이 능력
- UA-OST: 클라이언트 기기에서 동작 중인 운영체제의 이름과 버전
- UA-Pixels: 클라이언트 기기 디스플레이에 대한 픽셀 정보
- User-Agent: 요청을 보낸 애플리케이션 이름

***Accept 관련 헤더***

- Accept: 서버에게 서버가 보내도 되는 미디어 종류 안내
- Accept-Charset: 서버에게 서버가 보내도 되는 문자 집합 안내
- Accept-Encoding: 서버에게 서버가 보내도 되는 인코딩 안내
- Accept-Language: 서버에게 서버가 보내도 되는 언어 안내
- TE(Transfer-Encoding): 서버에게 서버가 보내도 되는 확장 전송 코딩 안내

***조건부 요청 헤더***

- Except: 클라이언트가 요청에 필요한 서버의 행동 열거
- If-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서 가져오기
- If-Modified-Since: 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청 제한
- If-None-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서 가져오기
- If-Range: 문서의 특정 범위에 대한 요청을 할 수 있게 해줌
- If-Unmodified-Since: 주어진 날짜 이후에 리소스가 변경되었다면 요청 제한
- Range: 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위 요청

***요청 보안 헤더***

- Authrization: 클라이언트가 서버에게 제공하는 인증 정보
- Cookie: 클라이언트가 서버에게 토큰을 전달할 때 사용. 진짜 보안 헤더는 아니지만, 보안에 영향을 줌
- Cockie2: 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용. [RFC 2965](https://tools.ietf.org/html/rfc2965)로 정의된 쿠키.

***프락시 요청 헤더***

- Max-Forwards: 요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE와 함께 사용
- Proxy-Authorization: Authrization 과 같지만, 프락시에서 인증을 할 때 사용.
- Proxy-Connection: Connection 과 같지만, 프락시에서 연결을 맺을 때 사용.

### 3.5.3 응답 헤더

- Age: 응답이 얼마나 오래되었는지
- Public: 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록
- Retry-After: 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시각
- Server: 서버 애플리케이션의 이름과 버전
- Title: HTML 문서에서 주어진 것과 같은 제목
- Warning: 사유 구절에 있는 것보다 더 자세한 경고 메시지

***협상 헤더***

- Accept-Ragnes: 서버가 자원에 대해 받아들일 수 있는 범위의 형태
- Vary: 서버가 확인해 보아야 하고,  그 때문에 응답에 영향을 줄 수 있는 헤더들의 목록.

***응답 보안헤더***

- Proxy-Authenticate: 프락시에서 클라이언트로 보낸 인증 요구의 목록
- Set-Cookie: 서버가 클라이언트를 인증할 수 있도록 클라이언트 측 토큰을 설정하기위해 사용
- Set-Cookie2: Set-Cookie와 유사하지만 [RFC 2965](https://tools.ietf.org/html/rfc2965)로 정의된 쿠키.
- WWW-Authenticate: 서버에서 클라이언트로 보낸 인증 요구의 목록

### 3.5.4 엔터티 헤더

- 메세지 내의 엔터티를 설명하는 헤더로, 엔터티가 요청/응답에 포함될 수 있으므로, 요청/응답 모두에 나타날 수 있음.
- 종류
    - Allow: 이 엔터티에 대해 수행될 수 있는 요청 메서드 나열
    - Location: 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해 줌. 수신자에게 리소스에 대한 (아마도 새로운) 위치(URL)를 알려줄 때 사용

***콘텐츠 헤더***

- Content-Base: 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL
- Content-Encoding: 본문에 적용된 어떤 인코딩
- Content-Language: 본문을 이해하는데 가장 적절한 자연어
- Content-Length: 본문의 길이나 크기
- Content-Location: 리소스가 실제로 어디에 위치하는지
- Content-MD5: 본문의 MD5 체크섬(checksum)
- Content-Range: 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현
- Content-Type: 이 본문이 어떤 종류의 객체인지

***엔터티 캐싱헤더***

- ETag: 엔터티에 대한 엔터티 태그
- Expires: 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시
- Last-Modified: 가장 최근 이 엔터티가 변경된 일시

## 4.1 TCP 커넥션

- 모든 HTTP 통신은 TCP/IP를 통해 이루어지며, 손실, 손상, 순서바뀜없이 안전하게 전달됨
- URL을 입력 받은 브라우저가 수행하는 단계
    1. 브라우저가 URL에서 호스트명을 추출한다
    2. 브라우저가 호스트명에 대한 IP주소를 찾는다
    3. 브라우저가 포트번호(80)를 얻는다
    4. 브라우저가 202.43.78.3의 80포트로 TCP 커넥션을 생성한다
    5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다
    6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다
    7. 브라우저가 커넥션을 끊는다

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 몇 사용 규칙을 제외하고 TCP 커넥션에 불과하므로 TCP의 기초 내용을 알아야 함
- TCP는 인터넷을 안정적으로 연결해주며, HTTP에게 신뢰할 만한 통신 방식 제공.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 IP 패킷(=IP 데이터그램)이라는 조각을 통해 데이터 전송.
    - TCP는 세그먼트라는 단위로 데이터스트림을 나누고, IP 패킷으로 감싸 인터넷을 통해 전달
    - IP 패킷의 구조
        - IP 패킷 헤더(보통 20byte)
            - 목적지 IP 주소, 크기, 기타 플래그
        - TCP 세그먼트 헤더(보통 20byte)
            - TCP 포트 번호, TCP 제어 플래그, 데이터 순서 및 무결성 검사용 숫자 값
        - TCP 데이터 조각(0혹은 그 이상)

### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있으며, TCP는 포트 번호를 통해 여러 개의 커넥션을 유지
    - IP주소는 해당 컴퓨터로 연결되고, 포트 번호는 해당 어플리케이션으로 연결
- TCP 커넥션은 4가지 값으로 식별
    - <발신지 IP 주소, 발신 포트, 수신지 IP주소 , 수신지 포트>
    - 서로 다른 두개의 TCP는 4가지 주소 구성 요소 값이 다 같을 수 없음 (일부가 같을 수는 있음)

### 4.1.4 TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 기능을 제공.
    - 소켓 API는 유닉스 OS용으로 개발 되었으나, 지금은 대부분의 운영체제 와 프로그램 언어에서 사용 가능
    - TCP 소켓 API의 주요 인터페이스
        - `s = socket(<parameters>)` : 연결이 되지 않은 익명의 새 소켓 생성
        - `bind(s, <local IP:port>)` : 소켓에 로컬 포트 번호와 인터페이스 할당
        - `connect(s, <remote IP:port>)` : 로컬의 소켓과 원격의 호스트, 포트 사이에 TCP 커넥션 생성
        - `listen(s, ...)` : 커넥션을 받아들이기 위해 로컬 소켓에 허용함을 표시
        - `s2 = accept(s)` : 누군가 로컬 포트에 커넥션을 맺기를 기다림
        - `n = read(s, buffer, n)` : 소켓으로부터 버퍼에 n바이트 읽기 시도
        - `n = write(s, buffer, n)` : 소켓으로부터 버퍼에 n바이트 쓰기 시도
        - `close(s)` : TCP 커넥션을 완전히 끊음
        - `shutdown(s, <side>)` : TCP 커넥션의 입출력만 닫음
        - `getsockopt(s, ...)` : 내부 소켓 설정 옵션 값을 읽음
        - `setsockopt(s, ...)` : 내부 소켓 설정 옵션 값을 변경
- 소켓 API를 사용하면 TCP 종단(endpoint)데이터 구조 생성, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림 읽고 쓰기 가능.
- TCP API는 기본적인 네트워크 프로토콜의 핸드 셰이킹, TCP 데이터 스트림, IP 패킷간의 분할 및 재조립에 대한 세부사항을 숨김
- 클라이언트-서버 간의 HTTP 트랜잭션을 수행하는 소켓 API 슈도코드. C(Client), S(Server)
    1. [S1] 새 소켓 만들기(`socket`)
    2. [S2] 80포트로 소켓을 묶기
    3. [S3] 소켓 커넥션 허가(`listen`)
    4. [S4] 커넥션 대기
    5. [C1] IP 주소와 포트 얻기
    6. [C2] 새로운 소켓 생성(`socket`)
    7. [C3] 서버의 IP:포트로 연결(`connect`)
    8. [S5] 애플리케이션 커넥션 통지
    9. [C4] 성공적으로 연결 
    10. [C5] HTTP 요청을 보내기(`write`) / [S6] 요청 읽기 시작(`read`)
    11. [C6] HTTP 응답 대기(`read`) 
    12. [S7] HTTP 요청 메세지 처리
    13. [S8] HTTP 응답 보내기(`write`) / [C7] HTTP 응답 처리
    14. [S9] 커넥션 닫기(`close`) / [C8] 커넥션 닫기(`close`)

## 4.2 TCP 성능에 대한 고려

- HTTP 트랜잭션의 성능은 TCP 성능에 영향을 받음

### 4.2.1 HTTP 트랜잭션 지연

- 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생
    - 트랜잭션 처리 시간은 TCP 커넥션설정/요청, 응답 전송 시간 대비 짧음.
- 트랜잭션을 지연시키는 원인
    1. (방문 히스토리가 없을 때) DNS 이름 분석 인프라를 통해 IP주소로 변환하는데 걸리는 시간
        - 현재는 인터넷 인프라의 발전으로 밀리초 단위 내로 끝남
    2. 커넥션 설정 시간
        - 새로운 TCP 커넥션 마다 1초 미만의 설정 시간이 소요되지만, 수백 개의 HTTP 트랜잭션이 만들어지면 소요 시간이 크게 증가
    3. 커넥션이 맺어지고 요청 메시지가 TCP 파이프를 통해 전달되고 서버에 의해 처리되는 데까지의 시간
    4. 웹 서버가 HTTP 응답을 보내는 시간
- 그 외, 하드웨어 성능, 네트워크와 서버 전송 속도, 요청과 응답메시지의 크기, 클라이언트와 서버간의 거리, TCP 프로토콜의 기술적인 복잡성이 지연에 영향을 미침

### 4.2.2 성능 관련 중요 요소

- HTTP 프로그래머에게 영향을 주는 가장 일반적인 TCP 관련 지연
    - 4.2.3 TCP 커넥션의 핸드 셰이크 설정
    - 4.2.5 인터넷 혼잡 제어용 TCP 의 느린 시작(slow-start)
    - 4.2.6 데이터를 한데 모아 한번에 전송하기 위한 네이글(nagle) 알고리즘
    - 4.2.4 TCP 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
    - 4.2.7 TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 새로운 커넥션을 열 때, TCP 소프트웨어는 커넥션을 맺는 조건을 맞추기 위해 연속으로 IP 패킷 교환
    - 작은 크기의 데이터 전송에 커넥션이 사용되면 패킷 교환이 HTTP 성능을 저하
- TCP 핸드셰이크 순서
    1. 클라이언트가 새 TCP 커넥션을 생성하기위해 작은 TCP 패킷(보통 40~60 byte)를 서버에 전송.
        - 커넥션 생성 요청을 의미하는 SYN 플래그를 포함
    2. 해당 커넥션을 받으면 커넥션 매개 변수를 산출하고 커넥션 요청이 받아들여졌다는 뜻의 'SYN'와 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에 전송 
    3. 클라이언트는 커넥션이 잘 맺여졌음을 알리기 위해 확인 응답신호('ACK')를 전송. 오늘날의 TCP는 이 확인응답과 함께 데이터를 보낼 수 있음
- HTTP 프로그래머는 패킷은 보지 못하고, 새 TCP 커넥션 생성에 대한 지연만 알 수 있다.
- HTTP 트랜잭션이 큰 데이터를 주고 받지 않으면, TCP 구성에 더 많은 시간을 써서 눈에 띄는 지연 발생
    - TCP의 ACK 패킷은 HTTP 요청 메세지 전체를 전달할 수 있을만큼 큼
    - 많은 HTTP 서버 응답 메시지는 하나의 IP 패킷에도 담길 수 있음
- TCP 구성으로 인한 지연을 제거하기 위해 어떻게 HTTP가 기 존재하는 커넥션을 재활용하는지 알아볼 것

### 4.2.4 확인응답 지연

- 인터넷 자체가 패킷 전송을 보장하는 것이 아니므로(인터넷 라우터는 과부하시에 패킷 파기 가능), TCP는 성공적인 데이터 전송 보장을 위해 자체 확인 체계를 갖음
- 각 TCP 세그먼트는 순번, 데이터 무결성 체크섬 포함.
    - 수신자가 세그먼트를 잘 받으면 확인 응답 패킷을 송신자에게 반환
    - 송신자가 확인 응답 메세지를 받지 못하면 패킷이 파기되거나 오류가 있는 것으로 판단하여 재전송
- 확인 응답은 크기가 작아서, TCP는 같은 방향으로 송출되는 데이터 패킷에 확인 응답을 [편승(piggyback)](http://www.ktword.co.kr/abbr_view.php?m_temp1=3242)
    - 송출 데이터 패킷 + 확인 응답을 묶어 보내 효율적으로 사용
    - 편승을 늘리기 위해서 많은 TCP 스택은 '확인 응답 지연' 알고리즘 구현
        - 확인응답을 특정 시간(보통 0.1~0.2초) 동안 버퍼에 저장, 편승시키기 위한 송출 데이터 패킷 탐색
        - 일정 시간내에 못찾으면 별도 패킷으로 전송
- HTTP 동작방식은 요청/응답만 있어서 확인 응답이 송출 데이터 패킷에 편승할 확률이 적다.
    - 확인 응답 지연 알고리즘으로 인해 지연이 자주 발생.
    - 운영체제에 따라 다르지만, 지연관련 기능을 수정/비활성화 할 수 있음
- TCP 내부 알고리즘은 잘못 만들어진 애플리케이션으로부터 인터넷을 보호하도록 설계 되어있음
    - TCP 설정 수정시, 기존 알고리즘이 피하려는 문제를 애플리케이션이 발생시키지 않을 것이라고 확신할 수 있어야 함

### 4.2.5 TCP 느린시작(slow start)

- TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'된다
    - TCP 커넥션 생성 초기에 최대 속도를 제한하다가 데이터가 잘 전송됨에 따라 속도 제한을 높여감
    - 조율하는 것을 TCP 느린 시작이라고 하며, 갑작스런 인터넷 부하와 혼잡 방지에 사용
- TCP 느린 시작은 TCP가 한번에 전송할 수 있는 패킷 수를 제한
    - HTTP 트랜잭션에서 전송할 데이터가 많아도, 처음부터 한번에 전송할 수 없음
    - 한 개의 패킷 전송 후 확인응답을 받으면 2개의 패킷을 보낼 수 있고, 그 패킷에 대한 확인 응답에 각각 2개의 패킷을 보낼 수 있음. (1 → 2 → 4 → 8 → ...)
        - 혼잡 윈도를 연다(opening the congestion window)고 한다
- 혼잡 제어 기능 때문에, 새 커넥션은 튜닝된 커넥션보다 느림
    - 튜닝된 커넥션이 빠르므로, 이미 존재하는 커넥션을 재사용하는 기능이 있음

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 애플리케이션이 어떤 크기의 데이터(1바이트라도)든지 TDP 스택으로 전송할 수 있도록 TCP는 데이터 스트림 인터페이스 제공.
    - 각 TCP 세그먼트는 40바이트 상당의 플래그, 헤더를 포함하므로 작은 데이터를 자주 보내면 성능이 떨어짐
- 네이글 알고리즘(John Nagle 발명)은 효율을 위해, 패킷 전송 전 많은 양의 TCP 데이터를 한 덩어리로 합침
    - 세그먼트 최대 크기(LAN상 1,500byte/인터넷 상 수백byte)가 되지 않으면 미전송.
    - (1) 모든 패킷이 확인 응답 받았거나 (이때는 최대 크기 이하도 전송) (2) 전송하기 충분한 패킷이 쌓였으면 데이터 전송.
- 네이글 알고리즘은 HTTP 성능에 문제를 발생시킴
    1. 작은 HTTP 메시지는 패킷을 못 채워, 앞으로 생길지 모를 데이터를 기다리며 지연 됨.
    2. 네이글 알고리즘은 확인응답 지연과 함께 쓰이면 지연이 길어짐.
        - 확인 응답 도착시까지 데이터 전송 대기(네이글) + 확인 응답을 지연
- 성능 향상을 위해 HTTP 스택에 TPC_NODELAY 파라미터를 이용하여 네이글알고리즘 비활성화 가능
    - 작은 크기의 패킷이 너무 많이 생기지 않도록 유의

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT 포트 고갈은 성능 측정시에 심각한 성능 저하 발생, 하지만 보통 실제 상황에는 문제 없음
- TCP 커넥션 종단에서 TCP 커넥션을 끊으면, 종단에서 커넥션의 IP주소와 포트를 메모리의 작은 제어 영역(control block)에 기록
    - 같은 주소, 포트 번호를 사용하는 새 TCP 커넥션이 일정 시간 동안 생성되지 않게 하기 위함
    - 이전 커넥션과 관련된 패킷이 새 커넥션에 삽임되는 문제 방지.
    - 세그먼트 최대 생명주기의 2배(2MSL, 보통 2분) 정도 유지
- 현대의 빠른 라우터덕에 커넥션이 닫힌 후에 중복되는 패킷이 생기는 경우가 거의 없음.
- 2MSL를 더 짧은 값으로 수정하는 운영체제도 있지만, 값 수정에 조심
    - 이전 커넥션 패킷이 새 커넥션에 삽입되면 패킷 중복 및 TCP 데이터 충돌 발생
- 성능 측정 시험 시에는, 가능한 커넥션 조합이 제한되고, 포트 재활용이 불가능함.
    - 실제 상황에 문제는 없으며 생각지도 못했던 성능상의 문제가 생긴 것으로 오해할 수 있음
    - 성능 측정시 관련 내용은 책을 참조

## 4.3 HTTP 커넥션 관리

- HTTP 커넥션 관리에 중요한 HTTP 커넥션 헤더와 최적화 기술에 대해 알아 보기

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP는 클라이언트와 서버 사이에 중개 서버(프락시 서버, 캐시 서버 등)를 허락
    - 두 인접한 HTTP 애플리케이션이 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있음.
- HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표(,)로 구분하여 가지며, 다른 커넥션에 전달 되지 않음.

    ```
    HTTP/1.1 200 OK
    Cache-control: max-age=3600
    Connection: meter, close, bill-my-credit-card
    Meter: max-uses=3, max-refues=6, dont-report
    ```

- Connection 헤더에는 다음 세 가지 종류의 토큰이 전달될 수 있음. 혼란 주의
    - HTTP 헤더 필드 명: 이 커넥션에만 해당 되는 헤더 나열. (예: `meter`)
    - 임시적 토큰 값: 커넥션에 대한 비표준 옵션 (예: `bill-my-credit-card`)
    - `close` 값: 작업이 완료되면 커넥션이 종료되어야 함을 의미
- Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳에 전달하는 시점에 삭제 되어야 함.
    - Connection 헤더에는 홉별(hop-by-hop) 헤더 명을 기술. '헤더 보호하기'라고 함
- HTTP 애플리케이션이 Connection 헤더와 메세지를 전달 받으면, 수신자는 요청에 기술되어 있는 모든 옵션 적용.
    - 다음 홉에 메시지 전달 전에 Connection 헤더와 헤더 내에 기술되어있던 모든 헤더 삭제.
    - Connection 헤더에 기술되지 않은 홉별 헤더도 있음.
        - `Proxy-Authenticate`, `Proxy-Connection`, `Transfer-Encoding`, `Upgrade`

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리가 잘 되지 않으면 TCP 성능이 나빠짐.
- 순차적 트랜잭션 처리 예시: 3개의 이미지가 있는 웹 페이지 = 4개(1 HTML + 3 이미지)의 트랜잭션
    - 각 트랜잭션이 새 커넥션을 필요로 하면, 커넥션 맺을 때 발생하는 지연과 느린 시작 지연이 발생
    - 모든 객체를 받기 전까지 빈 화면이므로(개발 사항에 따라 다를 수 있음) 사용자는 심리적 지연을 느낌
- HTTP 커넥션 성능을 향상 시킬 수 있는 기술 4가지.
    1. 병렬(parallel) 커넥션
        - 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
    2. 지속(persistent) 커넥션
        - 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
    3. 파이프라인(pipelined) 커넥션
        - 공유 TCP 커넥션을 통한 병렬 HTTP 요청
    4. 다중(multiplexed) 커넥션
        - 요청과 답변들에 대한 중재. 실험적 기술

## 4.4 병렬 커넥션

- HTTP 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리 가능.

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹페이지를 더 빠르게 내려받을 수 있음.
    - 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있음
    - 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다쓰는게 아니면 남은 대역폭을 다른 객체를 받는데 사용 가능

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 일반적으로 더 빠르기는 하지만 항상 빠르지는 않다.
- 클라이언트의 네트워크 대역폭이 좁을 때(예: 28.8Kbps 모뎀으로 연결된 경우)는 대부분의 시간을 데이터 전송에만 사용하게 됨
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제 발생
    - 복잡한 웹 페이지는 수 십~수 백 개의 개체 포함
    - 서버는 다른 여러 사용자의 요청도 처리해야하기 대문에 수백개의 커넥션을 허용하지는 않음
    - 100명의 사용자에 100개의 커넥션을 맺고있다면 10,000개의 커넥션을 떠안아 성능이 떨어짐.
- 실제로는 병렬 커넥션을 사용하지만 적은 수(보통 6~8개)의 커넥션을 허용.
    - 특정 클라이언트가 과도한 커넥션이 맺어진 경우 임의로 서버가 끊을 수 있음

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 실제로 페이지를 더 빠르게 내려받는 것이 아니더라도, 사용자는 빠르게 느껴질 수 있다
    - 총 다운로드 시간이 더 걸리더라도, 작업이 일어나는 것으로 눈으로 확인할 수 있어서

## 4.5 지속 커넥션

- 웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺음
    - 웹 페이지 내에 첨부된 이미지, 하이퍼링크 등도 같은 사이트 내에 있음.
    - 서버에 HTTP 요청을 시작한 애플리케이션이 웹 페이지내 다른 것을 가져오기 위해 그 서버에 다시 요청하는 속성을 사이트 지역성(site locality)라 함.
- HTTP/1.1 을 지원하는 기기는 처리가 완료된 후에 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용 할 수 있음
    - 처리가 완료된 이후에도 계속 연결된 상태로 유지하는 TCP 커넥션을 **지속 커넥션** 이라고 부름
    - 비지속 커넥션은 각 처리가 끝날 때마다 커넥션을 끊지만, 지속 커넥션은 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지
- 이미 맺어진 지속 커넥션을 재사용함으로써, 커넥션 준비 시간을 절약할 수 있음.
    - TCP 느린 시작으로 인한 지연도 피할 수 있음

### 4.5.1 지속 커넥션 vs 병렬 커넥션

- 병렬 커넥션의 단점:
    1. 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간 및 대역폭 소모
    2. 각각의 새 커넥션은 TCP 느린 시작 때문에 성능이 떨어짐
    3. 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있음
- 지속 커넥션의 병렬 커넥션 대비 장점
    1. 커넥션을 맺기 위한 사전 작업, 지연을 줄여줌
    2. 튜닝된 커넥션을 유지함
    3. 커넥션수를 줄여줌
- 지속 커넥션을 잘못 관리하는 경우
    - 연결된 상태로 있는 수많은 커넥션이 쌓임.
    - 로컬 리소스, 원격 클라이언트, 서버의 리소스에 불필요한 소모 발생
- 지속 커넥션은 병렬 커넥션과 함께 사용시 가장 효과적. 오늘날은 적은 수의 병렬 커넥션을 맺고 유지함
- 지속 커넥션 타입:
    1. HTTP/1.0+ 에 'keep-alive'
    2. HTTP/1.1 '지속' 커넥션

### 4.5.2 HTTP/1.0+ 의 Keep-Alive 커넥션

- HTTP/1.0 브라우저/서버는 실험적이었던 keep-alive 커넥션을 지원, 초기 버전은 설계에 문제가 있지만 HTTP/1.1 에서 수정됨
- keep-alive 커넥션은 커넥션을 맺고 끊는데 필요한 작업이 없어서 시간이 단축됨. (TCP 느린 시작 발생 X)

### 4.5.3 Keep-Alive 동작

- keep-alive는 HTTP/1.1 명세에서 제거됨.
    - 하지만 아직 널리 사용하기 때문에, 그것을 처리할 수 있게 개발되어야함.
- keep-alive 동작 방식
    - keep-alive 핸드셰이크: [RFC 2068](https://tools.ietf.org/html/rfc2068)(HTTP/1.1 이전 명세) 참조
    - 클라이언트는 커넥션을 유지하기 위해 `Connection: Keep-Alive` 헤더를 포함
    - 서버는 그다음 요청도 이 커넥션에서 받고자 한다면, 같은 헤더를 포함하여 응답
    - 클라이언트는 `Connection: Keep-Alive` 가 없으면, 지원하지 않는다고 판단해 커넥션을 끊을 것이라 추정

### 4.5.4 Keep-Alive 옵션

- Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐, 실제로 서버나 클라이언트가 따를 필요는 없음
    - 언제든지 keep-alive 커넥션을 끊을 수 있고, keep-alive 커넥션에서 처리되는 트렌잭션 수 제한 가능
- keep-alive 의 동작은 Keep-Alive 헤더의 쉼표로 구분된 옵션으로 제어 가능
    - `timeout` 파라미터. Keep-Alive 응답 헤더를 통해 보냄. 커넥션이 얼마간 유지될 것인지 의미. 보장X
    - `max` 파라미터. Keep-Alive 응답헤더를 통해 보냄. 커넥션이 몇개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지 의미
    - Keep-Alive 헤더는 진단이나 디버깅을 주 목적으로 하는, 처리되지 않은 임의의 속성도 지원. `이름[=값]`
- Keep-Alive 헤더 사용은 선택 사항이지만, Connection: Keep-Alive 헤더가 있을 때만 사용 가능
- 5개의 추가 트랜잭션이 처리 될동안 커넥션을 유지하거나, 2분동안 커넥션을 유지하라는 내용의 Keep-Alive 응답 헤더

    ```
    Connection: Keep-Alive
    Keep-Alive: max=5, timeout=120
    ```

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- keep-alive 는 HTTP/1.0에서 기본적으로 사용되지 않음
    - keep-alive 커넥션을 사용하려면 Connection: Keep-Alive 요청 헤더 필요
- 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 요청 헤더 필요
    - 클라이언트가 해당 요청 헤더를 보내지 않으면 서버는 요청을 처리 후 커넥션을 끊음
    - 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답 후 커넥션 끊을 것음을 알 수 있음
- 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알아야 커넥션 유지 가능
    - 엔터티 본문이 정확한 Content-Length 값, 멀티파트 미디어 형식(multipart media type)을 갖거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어야 함을 뜻함
    - keep-alive 커넥션에서 잘못된 Content-Length 값을 보내면, 트랜잭션이 끝나는 시점에 기존 메시지의 끝과 새 메시지의 시작점을 정확히 알 수 없어서 좋지 않음
- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야함
    - 프락시와 게이트웨이는 메시지 전달하거나 캐시 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야함
- 정석대로라면, keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와 맺어지면 안됨
    - 4.5.6의 멍청한(dumb) 프락시로 인해 발생할 문제를 예방하기 위함이지만, 현실적으로 쉽지 않음
- 기술적으로 HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드(Connection: Keep-Alive 포함)은 무시해야 한다. 오래된 프락시 서버로부터 실수로 전달 될 수 있기 때문.
    - 어떤 클라이언트나 서버는 오래된 프락시에 행(hang)이 걸릴 수 있는 위험이 있음에도 이 규칙을 지키지 않기도 함.
- 클라이언트는, 응답 전체를 받기 전에 커넥션이 끊어졌을 경우, 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비 되어있어야 함.
    - 그렇지 않으면 요청이 반복될 경우 문제가 발생할 수 있음

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

- 클라이언트 요청에 Connection: Keep-Alive 헤더가 있으면, 클라이언트가 현재 연결하고 있는 TCP 커넥션을 끊지 않으려고 유지한다는 의미
- 서버가 keep-alive 를 지원한다면 헤더를 응답에 포함하고, 지원하지 않는다면 포함하지 않을 것이다.

***Connection 헤더의 무조건 전달***

- 프락시는 Connection 헤더를 이해하지 못하고 해당 헤더를 삭제하지 않고다음 프락시에 전달 함.
    1. 웹 클라이언트가 프락시에 Connection: Keep-Alive 헤더와 함께 메시지 보내고 응답 대기
    2. 멍청한 프락시가 요청받은 HTTP 의 Connection 헤더(단순 확장 헤더로 취급)을 이해하지 못해, 그대로 다음 서버에 메시지 전달.
        - 하지만 Connection 헤더는 홉별(hop-by-hop) 헤더(한개의 전송링크에 적용되며 다음 서버로 전달이 안됨). 여기에서 문제 시작
    3. 전달된 HTTP 요청이 서버에 도착. 웹 서버는 Connection: Keep-Alive 헤더를 받아서 프락시가 커넥션을 유지하자가 요청하는 것으로 판단. 
        - 서버는 프락시와의 커넥션 유지에 동의하고 Connection: Keep-Alive 헤더를 포함하여 응답.
    4. 멍청한 프락시는 서버로부터의 Connection: Keep-Alive 헤더를 포함한 응답 메시지를 클라이언트에 전달
        - 클라이언트는 프락시가 커넥션 유지에 동의했다고 추정.
    5. 프락시는 받은 모든 데이터를 클라이언트에 전송 후, 서버가 커넥션을 끊기를 대기. 하지만 서버는 커넥션 유지를 요청한 것으로 알아서 커넥션을 끊지 않음. 프락시는 커넥션이 끊어지기 전까지 계속 커낵션 끊기를 대기 
    6. 클라이언트가 응답 메시지를 받은 이후, 커넥션이 유지되고 있는 프락시에 다음 요청을 보내기 시작. 프락시는 같은 커넥션 상에서 다른 요청이 오는 경우는 예상하지 못하기 때문에 요청 무시
        - 브라우저는 아무 응답없이 로드 중으로 표시
    7. 이런 잘못된 통신 때문에, 브라우저 자신이나 서버가 타임 아웃 나서 커넥션이 끊길 때까지 대기.
- 그 외에도 무조건 전달(blind relay)과 핸드셰이크의 전달(forwarded handshaking)으로 문제 발생하는 경우도 있음

***프락시와 홉별 헤더***

- 이런 잘못된 통신을 피하려면 프락시는 Connection헤더 및 Connection 헤더에 명시된 헤더를 전달하면 안됨.
    - Connection: Keep-Alive 헤더를 받으면 Connection헤더와 Keep-Alive헤더도 전달하면 안됨.
- Connection 헤더 값으로 명시되지 않는 홉별 헤더도 전달하면 안됨
    - `Proxy-Authenticate`, `Proxy-Connection`, `Transfer-Encoding`, `Upgrade` 등

### 4.5.7 Proxy-Connection 살펴보기

- 넷스케이프 브라우저 및 프락시 개발자는 모든 웹 애플리케이션이 HTTP 최신버전을 지원하지 않아도 모든  헤더를 전달하는 문제를 해결할 수 있는 차선책 제시
    - 클라이언트의 요청이 중개서버를 통해 이어지는 경우에 모든 헤더를 전달하는 문제를 해결하기 위해 Proxy-Connection이라는 헤더를 사용하는 것(모든 상황에서 동작하지는 않음)
    - Proxy-Connection은 프락시를 별도로 설정할 수 있는 현대의 브라우저들에서 지원하며, 많은 프락시들도 인식
- 멍청한 프락시 문제 해결을 위해 브라우저에서 일반적으로 전달하는 Connection헤더 대신 비표준인 Proxy-Connection 확장 헤더를 프락시에 전달
    - 프락시가 Proxy-Connection 헤더를 무조건 전달하더라도 웹 서버가 무시하므로 문제가 없음.
    - (지속 커넥션 핸드 셰이킹을 이해할 수 있는) 영리한 프락시라면, 의미없는 Proxy-Connection 헤더를 Connection 헤더로 변경하여 원하던 효과를 얻게 됨
- 이 방식은 클라이언트와 서버 사이에 한개의 프락시만 있는 경우에만 동작
    - 멍청한 프락시 양옆에 영리한 프락시가 잇다면, 동일하게 잘못된 헤더를 만들어 내는 문제가 발생
- 문제를 일으키는 프락시들은 방화벽, 캐시 서버, 리버스 프락시 서버 가속기와 같이 네트워크상 '보이지 않는' 경우게 많음.
    - 브라우저는 이러한 기기를 볼 수 없으므로 Proxy-Connection 헤더를 보낼 수 없음.
    - 보이지 않는 웹 애플리케이션들이 지속 커넥션을 명확히 구현하는 것이 중요

### 4.5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.1 에서는 keep-alive 커넥션을 지원하지 않는대신, 설계가 개선된 지속 커넥션을 지원
    - 목적은 keep-alive와 같지만 더 잘 동작함
- HTTP/1.0의 keep-alive와 달리 HTTP/1.1 지속 커넥션은 기본으로 활성화
    - HTTP/1.1은 별도 설정이 없으면 모든 커넥션을 지속 커넥션으로 취급
    - HTTP/1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connect: close 헤더를 명시해야 함
    - keep-alive 커넥션이 선택 사항이 아닐 뿐 아니라 지원자체를 하지 않는 점에서 HTTP.0과 크게 다름
- HTTP/1.1 클라이언트는 응답에 Connection: close 헤더가 없으면 커넥션을 유지하는 것으로 추정
    - 하지만 언제든 클라이언트/서버는 언제든지 커넥션을 끊을 수 있음
    - = Connection: close 를 보내지 않는 것이 커넥션을 영원히 유지하겠다는 뜻은 아님

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈다면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없음
- 클라이언트가 해당 커넥션으로 추가적인 요청을 보낼 것이 아니라면 마지막 요청에 Connection: close 헤더를 추가해야함
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션 지속 가능
    - 엔티티 본문은 정확한 Content-Length 값을 갖거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어야 함
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도 지속 커넥션을 맺고 관리해야함
- HTTP/1.1 프락시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺으면 안됨
    - 오래된 프락시가 Connection 헤더를 전달하는 문제. 현실적으로 쉽지 않고, 많은 벤더가 지키지 않고 있음
- 서버는 메시지 전송 중간에 커넥션을 끊지 않을 것이고, 커넥션이 끊기기 전에 최소 한개의 요청에 대해 응답할 것이지만, HTTP/1.1 기기는 Connection 헤더의 값과 별개로 언제든지 커넥션을 끊을 수 있음
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구 할 수 있어야 함.
    - 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 함
- 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면, 요청을 반복해서 보내도 문제가 없는 경우에 요청을 다시 보낼 준비가 되어 있어야함.
- 하나의 사용자 클라이언트는 서버 과부하 방지를 위해 넉넉잡아 두 개의 지속 커넥션 만을 유지해야 함.
    - N명의 사용자 → 2N개의 커넥션

## 4.6 파이프라인 커넥션

- HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있음. keep-alive 커넥션의 성능을 더 높임
    - 여러개의 요청은 응답이 도착하기 전까지 큐에 쌓임
    - 첫번째 요청이 서버에 전달되면, 이어서 두번째와 세번째 요청이 전달됨
    - 대기 시간이 긴 네트워크 상황에서 네트워크상의 왕복으로 인한 시간을 줄여 성능을 높임.
- 파이프라인 제약 사항
    - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인 전까지 파이프라인을 이어서는 안됨
    - HTTP 응답은 요청 순서와 같게 와야함.
        - HTTP는 메시지 순번이 매겨져 있지 않아서, 응답이 순서없이 오면 정렬시킬 방법이 없음
    - 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 파이프라인에 있으면 언제든지 다시 보낼 수 있어야함
        - 지속 커넥션 맺고 나서 바로 여러 개의 요청을 보낸다하더라도 서버는 일부 요청만 처리하고 커넥션을 임의로 끊을 수 있음. 남은 실채한 요청을 다시 커넥션을 맺고 보낼 수 있어야 함
    - HTTP 클라이언트는 POST 요청과 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안됨.
        - 에러 발생시에 파이프라인을 통한 요청 중에 어떤 것이 서버에서 처리됐는지 알 수 없음.
        - POST와 같은 비멱등(nonidempotent) 요청을 재차 보내면 문제가 생길 수 있으므로 보내면 안됨.

![https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png](https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png)

순차 커넥션 vs 지속 커넥션 vs 파이프라인 지속 커넥션

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리(특히 끊기)에는 명확한 기준이 없음. 관련 기술 문서도 별로 없음

### 4.7.1 '마음대로' 커넥션 끊기

- 어떠한 HTTP 클라이언트, 서버, 프락시든 언제든지 TCP 전송 커넥션을 끊을 수 있음
- 보통은 메시지를 다 보낸 다음에 끊지만, 에러가 있는 상황에서는 엉뚱한 곳에서 끊길 수 있음.
- 파이프라인 지속 커넥션도 동일한게 언제든지 임의로 끊을 수 있음
    - 지속 커넥션이 일정 시간 동안 요청을 전송하지 않고 유휴상태라 서버가 커넥션을 끊을 수 있음
    - 서버가 커넥션을 끊는 시점에 클라이언트가 데이터를 전송하지 않을 것이라고 확신할 수 없음

### 4.7.2 Content-Length와 Truncation

- 각 HTTP 응답 본문은 정확한 Content-Length 값을 가져야함.
    - 일부 오래된 서버는 자신이 커넥션을 끊으면 데이터 전송이 끝났다고 의미해서 Content-Length 값이 없거나 틀리게 응답하기도 함
- 클라이언트나 프락시가 커넥션이 끊어졌다는 응답 이후, 실제 전달된 엔터티 길이와 Content-Length 값이 일치하지 않거나, 존재하지 않으면 서버에 물어봐야 함
- 만약 수신자가 캐시 프락시일 경우 잠재적인 에러가 복합적으로 발생하는 것을 최소화하기 위해 응답을 캐시하면 안됨
- 프락시는 Content-Length 정정하려고 하지말고 바로 전달해야함

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 커넥션은 에러가 없어도 언제든지 끊을 수 있음. 예상치 못하게 끊겼을 때에 대한 대응이 되어있어야함.
    - 클라이언트가 트랜잭션 수행 중에 끊기면, 재시도하더라도 문제가 없으면 커넥션을 다시 맺고 재전송.
- 멱등한(idempotent) 요청(GET, HEAD, PUT, DELETE, TRACE)은 결과에 영향을 미치지 않으므로 재전송
- 비멱등한(nonidempotent) 요청(POST)는 끊겼을때에 결과를 알 수 없으므로 파이프라인을 통해 요청하면 안됨.
    - 비멱등 메서드나 순서에 대해 에이전트가 요청을 다시 보낼 수 있는 기능을 제공하더라도, 자동으로 재시도 하면 안됨
    - 대부분의 브라우저는 캐시된 POST 요청 페이지를 다시 로드하려 할 떄, 재 요청을 원하는지 묻는 대화상자 노출

### 4.7.4 우아한 커넥션 끊기

- TCP 는 양방향. 양쪽에 데이터 입력 큐/출력 큐가 있음.

***전체 끊기와 절반 끊기***

- 애플리케이션은 TCP 입력/출력 채널 중 한 개 이상 끊을 수 있다.
- `close()`  를 호출하면 TCP 커넥션의 입출력 채널의 커넥션을 모두 끊음.

# 05. 웹 서버

## 5.1 다채로운 웹 서버

- 웹 서버: 웹 서버 소프트웨어 / 웹 페이지 제공에 특화된 장비(컴퓨터 같은). 둘 다 지칭
- 웹 서버는 기능 형태 크기가 다양. 기능은 다 달라도 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에 돌려주는 것은 동일.

### 5.1.1 웹 서버 구현

- 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것.
    - HTTP 프로토콜 구현
    - 자신이 제공하는 리소스 관리
    - 웹 서버를 설정, 통제, 확장하기 위한 관리 기능 제공
- TCP  커넥션 관리에 대한 책임은 웹 서버와 운영체제가 나눠 갖음.
    - 운영체제는 컴퓨터 시스템의 하드웨어 관리, TCP/IP 네트워크 지원, 웹 리소스를 유지하기 위한 파일시스템, 현재 연산 활동을 제어하기 위한 프로세스 관리를 제공
- 웹 서버의 여러가지 형태
    1. 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치 및 실행할 수 있음
    2. 마이크로프로세서의 기적으로, 회사들이 사용자에게 판매할 기기안에 구현된 웹 서버를 내장 시켜 완전한 관리 콘솔로 제공. (예: 공유기가 웹 브라우저로 접근 가능한 관리 기능 제공)

### 5.1.2 다목적 소프트웨어 웹 서버

- 네트워크에 연결된 표준 컴퓨터 시스템에서 동작. 거의 모든 컴퓨터와 운영체제에서 동작.
    - 아파치 같은 오픈 소스 소프트웨어나, 마이크로소프트 같은 상용 소프트웨어가 있음
- 수만 가지 종류의 웹 서버 프로그램이 존재하지만, 그중 몇 가지 웹 서버 소프트웨어만이 널리 사용
    - [2014년 기준](https://news.netcraft.com/archives/2014/08/27/august-2014-web-server-survey.html): 마이크로소프트(37%), 아파치(35%), nginx(14%), ...
    - [2020년 기준](https://news.netcraft.com/archives/category/web-server-survey/): nginx(34%), 아파치(27%), 마이크로소프트(8%), ...

### 5.1.3 임베디드 웹서버

- 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버.(예: 프린터나 가전제품)
    - 몇몇 임베디드 웹 서버는 매우 작은 크기로 구현되어 있고, 보통 최소한의 기능만 제공

## 5.2 간단한 펄 웹 서버

- 완전한 기능을 갖춘(풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 그 외 성능을 위한 각종 기능) HTTP 서버 개발은 할일이 좀 많지만, 최소한으로 기능하는 HTTP 서버는 30줄 이하의 펄(Perl)코드로 개발 가능
- 다음 코드는 HTTP 디버깅을 사용 되는 type-o-serve 라고 하는 펄 프로그램이다.
    - HTTP 커넥션을 기다리고, 요청 메시지를 받아 화면에 출력하고, 클라이언트에게 답할 응답을 기다렸다가 전송.

```perl
#!/usr/bin/perl

use Socket;
use Carp;
use FileHandle;

# (1) 명령줄에서 덮어쓰지 않는 이상 8080 포트를 기본으로 사용
$port = (@ARGV? @ARGV[0] : 8080);

# (2) 로컬 TCP 소켓을 생성하고 커넥션을 기다리도록(listen) 설정한다.
$proto = getprotobyname('tcp');
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메시지를 출력한다
printf("   <<<Type-O-Serve Accepting on Port %d>>>\n\n",$port);

while (1)
{
	# (4) 커넥션 C를 기다린다
	$cport_caddr = accept(C, S);
	($cport, $caddr) = sockaddr_in($cport_caddr);
	C->autoflush(1);

	# (5) 누구로부터의 커넥션인지 출력한다.
	$cname = gethostbyaddr($caddr, AF_INET);
	printf("   <<<Request From '%s'>>>\n",$cname);

	# (6) 빈 줄이 나올 때까지 요청 메시지를 읽어서 화면에 출력한다.
	while ($line = <C>)
	{
		print $line;
		if($line =~ /^\r/) { last; }
	}

	# (7) 응답 메시지를 위한 프롬프트를 만들고, 응답줄을 입력 받는다.
	#     "." 하나만으로 되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.

	printf("   <<Type Response Followed by '.'>>>\n");

	while ($line = <STDIN>)
	{
		$line =~ s/\r//;
		$line =~ s/\n//;
		if ($line =~ /^\./) { last; }
		print C $line . "\r\n";
	}
	close(C);
}
```

## 5.3 진짜 웹 서버가 하는 일

- 최신식 상용 웹 서버와 펄로 간단한 웹서버보다 훨씬 복잡하지만, 공통적으로 다음 일을 수행한다.
    1. 커넥션을 맺는다 
        - 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다
    2. 요청을 받는다. 
        - HTTP 요청 메시지를 네트워크로부터 읽어 들인다.
    3. 요청을 처리한다
        - 요청 메시지를 해석하고 행동을 취한다
    4. 리소스에 접근한다
        - 메시지에서 지정한 리소스에 접근한다
    5. 응답을 만든다
        - 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다
    6. 응답을 보낸다
        - 응답을 클라이언트에게 돌려준다
    7. 트랜잭션을 로그로 남긴다
        - 로그 파일에 트랜잭션 완료에 대한 기록을 남긴다

## 5.4 단계 1: 클라이언트 커넥션 수락

- 클라이언트가 이미 서버에 대해 열린 지속 커넥션을 갖고 있다면 그 커넥션을 사용할 수 있지만, 그렇지 않다면 새 커넥션을 열 필요가 있음

### 5.4.1 새 커넥션 다루기

- 클라이언트 → 서버 TCP 커넥션 요청시, 웹 서버는 TCP 커넥션에서 IP를 추출하여 어떤 클라이언트가 있는지 확인.
- 새 커넥션을 맺고 받아들여지면, 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 함.
- 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 닫을 수 있음.
    - 어떤 웹 서버는 클라이언트의 IP 주소, 호스트 명이 인가 되지 않았거나 악의적인 것으로 알려진 경우 커넥션을 닫음. 다른 신원 식별 기법 또한 사용할 수 있음.

### 5.4.2 클라이언트 호스트 명 식별

- 대부분의 웹 서버는 '역방향 DNS(reverse DNS)'를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환하도록 설정 되어있음
- 클라이언트 호스트 명을 구체적인 접근 제어, 로깅을 위해 사용할 수 있음
- 호스트 명 룩업(hostname lookup)은 많은 시간이 걸릴 수 있어 웹 트랜잭션을 느리게 할 수 있음
    - 많은 대용량 웹 서버는 꺼두거나 특정 콘텐츠에 대해서만 켜놓음

### 5.4.3 ident를 통해 클라이언트 사용자 알아내기

- 몇 웹서버는 IETF ident 프로토콜을 지원.
    - ident 프로토콜: 서버에게 어떤 사용자의 이름이 HTTP  커넥션을 초기화 했는지 찾아낼 수 있게 해줌
    - 웹 서버 로깅에서 유용한 정보로, 널리 쓰이는 일반 로그 포맷(Common Log Format)의 두번째 필드는 각 HTTP 요청의 ident 사용자 이름을 담고 있음. ([rfc931](https://tools.ietf.org/html/rfc931), [rfc1413](https://tools.ietf.org/html/rfc1413) 참조)
- HTTP 클라이언트 사용자의 이름을 알아내기 위한 ident 프로토콜 사용하기
    1. 클라이언트가 ident 프로토콜을 지원한다면, 클라이언트는 ident 결과를 위해 TCP 포트 133번을 listen.
    2. 클라이언트가 HTTP 커넥션을 연다
    3. 서버는 자신의 커넥션을 클라이언트의 identd 서버 포트(133)을 향해 연다
    4. 서버는 새 커넥션에 대응하는 사용자 이름을 묻는 간단한 요청을 보냄
- ident는 조직 내부에서는 유용하지만, 공공 인터넷에서는 잘 동작하지 않음
    - 많은 클라이언트 PC는 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않음
    - ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연
    - 방화벽이 ident 트래픽이 들어오는 것을 막는 경우가 많음
    - ident 프로토콜은 안전하지 않고 조작하기 쉬움
    - ident 프로토콜은 가상 IP주소를 잘 지원하지 않음
    - 클라이언트 사용자의 이름 노출로 인한 프라이버시 침해 우려
- 아파치의 경우 identityCheck 지시어를 이용해 ident 룩업을 사용하게 할 수 있음.
    - 가용한 ident 정보가 없으면 ident 로그 필드를 -으로 채움.
    - 보통은 ident 정보가 없기 때문에 일반 로그 포맷 로그 파일의 두 번쨰 필드는 -로 채워짐.

## 5.5 단계 2: 요청 메시지 수신

- 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어들이고 파싱하여 요청 메시지를 구성.
- 요청 메시지 파싱 시에 웹서버가 하는 일:
    - 요청 줄을 파싱하여 요청 메서드, 지정된 리소스 식별자(URI), 버전번호(없으면 HTTP/0.9로 인지하기도 함)를 찾음. 각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 캐리지 리턴 줄바꿈(CRLF) 문자열로 끝남
    - 메시지 헤더를 읽는다. 각 메시지 헤더는 CRLF 로 끝남.
    - 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다. (존재한다면)
    - 요청 본문이 있다면 읽어 들인다(길이는 Content-Length 헤더로 정의됨).
- 요청 메시지 파싱할 때, 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받음. 네트워크 커넥션은 언제라도 무효화 될 수 있음.
    - 웹 서버는 파싱해서 이해하는 것이 가능할 분량을 확보할 때까지 데이터를 네트워크로부터 읽어서 메시지 일부분을 메모리에 임시로 저장할 필요가 있음.

### 5.5.1 메시지의 내부 표현

- 몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료구조에 저장.
    - 자료구조는 요청 메시지의 각 조각에 대한 포인터, 길이를 담을 수 있음
    - 헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근 가능

### 5.5.2 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있음
    - 커넥션은 빠르게 요청을 보내거나, 요청이 느리거나, 요청이 가끔 오거나, 요청을 대기하고 있음
- 언제든지 요청이 도착할 수 있으므로, 웹 서버는 항상 새 요청을 주시함.
    - 웹 서버 아키텍처에 따라 요청을 처리하는 방식이 다름

***단일 스레드 웹 서버***

- 한번에 하나의 요청을 처리. 트랜잭션이 완료되면 다음 커넥션 처리
- 구현하기 간단한 아키텍처이지만, 처리 중에 다른 커넥션은 무시됨.
    - 심각한 성능 문제를 만들어내므로, 로드가 적은 서버나 type-o-serve같은 진단도구에만 적당

***멀티프로세스와 멀티스레드 웹 서버***

- 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스, 혹은 고 효율 스레드를 할당
    - 스레드/프로세스는 필요할 때마다 만들어질 수도 있고, 미리 만들어지기도 함(워커 풀)
- 일부 서버는 매 커넥션마다 스레드/프로세스를 하나씩 할당하지만, 대부분은 최대 개수에 제한을 둠
    - 수만 개의 동시 커넥션을 처리하게 되면 수많은 프로세스나 스레드가 메모리나 시스템 리소스를 소비함.

***다중 I/O 서버***

- 많은 웹서버가 대량의 커넥션을 지원하기위해 채택
- 모든 커넥션은 동시에 그 활동을 감시 당하며, 상태가 바뀌면 그 커넥션에 대한 작은 양의 처리를 수행
    - 그 처리가 완료되면, 커넥션은 다음 번 상태 변경을 위해 열린 커넥션 목록으로 돌아감.
    - 커넥션에 대해 작업을 수행하는 것은 커넥션에 해야할 일이 있을 때뿐, 유휴상태의 커넥션을 기다리지 않음.

***다중 멀티스레드 웹 서버***

- CPU가 여러 개인 경우, 이점을 살리기 위해 멀티스레딩과 다중화(multiplexing)을 결합.
- 여러 개의 스레드(보통 하나의 물리적 프로세스)는 각각 열려있는 커넥션(혹은 커넥션의 일부)를 감시하고 각 커넥션에 대해 조금씩 작업을 수행

## 5.6 단계 3: 요청 처리

- 웹 서버가 요청을 받으면, 요청으로부터 메서드, 리소스, 헤더, 본문(없을 수 있음)을 얻어 처리
    - POST와 몇 메서드는 요청 메시지에 엔터티 본문이 있을 것을 요구 함.
    - OPTIONS와 몇 메서드는 본문을 허용하지만 요구하지 않음.
    - GET은 엔터티 본문이 있는 것을 금지
- 상세한 내용은 다른 챕터에서 추후 진행

## 5.7 단계 4: 리소스의 매핑과 접근

- 웹 서버는 리소스서버임. HTML, JPEG와 같은 미리 만들어진 콘텐츠를 제공하며, 서버 위에 동작하는 리소스 생성 애플리케이션을 통해 만들어진 동적 콘텐츠도 제공.
- 클라이언트에 콘텐츠를 전달하려면, 요청메시지의 URI에 대응하는 알맞는 콘텐츠나 콘텐츠 생성기를 찾아서 식별해야함.

### 5.7.1 Docroot

- 웹 서버는 여러 종류의 리소스 매핑을 지원.
    - 그 중 가장 단순한 형태는 요청 URI = 웹서버의 파일 시스템 내 파일 이름으로 사용하는 것
- 일반적으로 웹 서버 파일 시스템의 특별한 폴더(**문서 루트, docroot**)를 웹 콘텐츠를 위해 예약 함
    - 웹 서버는 요청 메시지에서 URI를 가져와 문서 루트 뒤에 붙임
- `httpd.conf` 파일에 `DocumentRoot` 줄을 추가해 아파치 웹 서버의 문서 루트를 설정할 수 있음

    ```jsx
    DocumentRoot /usr/local/httpd/files
    ```

- 서버는 상대적인 URL이 docroot를 벗어나 이외의 부분이 노출되지 않도록 주의해야 함. (예: `http://www.google.com/../`) 대부분의 성숙한 웹서버는 미허용.

***가상 호스팅된 docroot***

- 가상 호스팅 웹 서버는, 각 사이트에 그들만의 분리된 문서 루트를 주어 한 서버에서 여러 개의 웹사이트를 호스팅함
- 가상 호스팁 웹서버는 URI/Host 헤더에서 얻은 IP주소나 호스트 명을 이용해 문서 루트 식별
- 가상으로 호스팅 되는 docroot 설정은 대부분 웹 서버에서 간단함

    ```
    # 아파치 웹 서버 가상 호스트 docroot 설정
    <VirtualHost www.joes-hardware.com>
    	ServerName www.joes-hardware.com
    	DocumentRoot /docs/joe
    	TransferLog /logs/joe.access_log
    	ErrorLog /logs/joe.error_log
    </VirtualHost>

    <VirtualHost www.marys-antiques.com>
    	ServerName www.marys-antiques.com
    	DocumentRoot /docs/mary
    	TransferLog /logs/mary.access_log
    	ErrorLog /logs/mary.error_log
    </VirtualHost>
    ...
    ```

***사용자 홈 디렉터리 docroots***

- 사용자들이 한 대의 웹 서버에 각자의 개인 웹 사이트를 만들 수 있도록 하는 것.
- `/~` 다음에 사용자 이름이 오는 것으로 시작하는 URI는 그 사용자의 개인 문서 루트를 가리킴
- 개인 docroot는 주로 사용자 홈 디렉터리 안에 있는 `public_html` 으로 불리는 디렉터리. (설정따라 다름)
    - `/~bob/index.html` → `/home/bob/public_html/...`

### 5.7.2 디렉터리 목록

- 웹 서버는 경로가 파일이 아닌 디렉터리를 가리키는 URL에 대한 요청을 받을 수 있음
- 대부분의 웹 서버는 디렉터리 URL 요청에 대해 다음과 같이 행동을 취하도록 설정 가능
    - 에러 반환
    - 디렉터리 대신할 특별한 '색인 파일' 반환
    - 디렉터리를 탐색해 그 내용을 담은 HTML 파일 반환. (대부분의 경우)
- 아파치 웹 서버에서 DirectoryIndex 설정 지시자를 사용하여 기본 디렉터리 파일로 사용될 파일 이름의 집합 설정 가능

    ```
    DirectoryIndex index.html index.htm home.html home.htm index.cgi
    ```

- 사용자가 디렉터리 URI를 요청했을 때 기본 색인 파일 없고, 디렉터리 색인 기능이 꺼져 있지 않다면, 많은 웹 서버는 자동으로 그 디렉터리 내의 파일들의 정보를 열거한 HTML 파일을 반환
    - 편리하지만, 보안 문제가 있다. 아파치 지시자로 색인 파일 자동 생성 끄기 가능.
    - `Option -Indexes`

### 5.7.3 동적 콘텐츠 리소스 매핑

- 대부분의 웹 서버는 URI를 동적 리소스(요청에 맞게 콘텐츠 생성)에 매핑 가능.
- 아파치는 URI의 경로명이 실행 가능한 프로그램이 위치한 디렉터리로 매핑되도록 설정하는 기능 제공

    ```
    ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/
    ```

    - URI경로가 `/cgi-bin/` 으로 시작하면 `/usr/.../cgi-programs/` 에서 프로그램을 찾아 실행하라는 뜻
- 아파치는 특정 확장자의 파일만 실행하도록 설정할 수 도 있음. 이 방법은 실행 가능한 스크립트를 아무 디렉터리에나 위치 시킬 수 있음.

    ```
    AddHandler cgi-script .cgi
    ```

    - `.cgi` 로 끝나는 모든 웹 리소스가 실행되어야 함을 명시.
- CGI는 웹 초창기에 널리 쓰인 서버사이드 애플리케이션 실행을 위한 인터페이스.

### 5.7.4 서버사이드 인클루드(Server-Side Includes, SSI)

- 많은 웹 서버가 지원하며, 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어있다면, 서버는 그 리소스 콘텐츠를 보내기 전에 처리.
- 서버는 콘텐츠에 변수 이름이나 내장된 스크립트가 될 수 있는 어떤 특별한 패턴이 있는지(주로 특별한 HTML 주석 안에 포함) 검사.
- 특별한 패턴은 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환. 동적 콘텐츠를 만드는 용도 사용.

### 5.7.5 접근 제어

- 웹 서버는 각각의 리소스에 접근 제어를 할당할 수 있음.
- 접근 제어되는 리소스에 대한 요청이 왔을 때, 클라이언트 IP 주소에 근거하여 접근을 제어 할 수 있고, 또는 리소스에 접근하기 위한 비밀번호를 물어볼 수 있음

## 5.8 단계 5: 응답 만들기

- 리소스 식별 후, 서버는 요청 메서드의 동작을 수행한 뒤 응답 메시지 반환
    - 응답 상태 코드, 응답 헤더, 응답 본문(생성되면) 포함

### 5.8.1 응답 엔터티

- 트랜잭션이 응답 본문을 생성한다면, 함께 반환.
- 응답메시지는 당므을 포함
    - 응답 본문의 MIME 타입을 기술하는 Content-Type
    - 응답 본문의 길이를 서술하는 Content-Length 헤더
    - 실제 응답 본문 내용

### 5.8.2 MIME 유형 결정하기

- 웹 서버는 응답 본문의 MIME 타입을 결정해야 함

***mime.types***

- 파일 이름의 확장자를 사용. 파일확장자별 MIME 타입이 담긴 파일을 탐색함.
- 가장 흔한 방법

***매직 타이핑(Magic typing)***

- 아파치 웹 서버는 MIME 타입을 알아내기 위해 파일 내용을 검사해서 알려진 패턴에 대한 테이블(매직 파일이라 불림)에 해당 패턴이 있는지 탐색.
- 느리지만 파일이 표준확장자 없이 이름이 지어진 경우에 편리

***유형 명시(Explit typing)***

- 파일 확장자나 내용에 상관없이 어떤 MIME 타입을 갖도록 웹 서버가 설정.

***유형 협상(Type negotiation)***

- 한 리소스가 여러 종류의 문서 형식에 속하도록 설정. 웹 서버가 사용자와의 협상 과정에서 가장 사용하기 좋은 형식(그리고 대응하는 MIME 타입)을 판별할 것인지 여부 설정 가능.
- 특정 파일이 특정 MIME 타입을 갖게끔 설정도 가능

### 5.8.3 리다이렉션

- 웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 성공 매시지 대신 리다이렉션 응답을 반환
- 리다이렉션 응답의 상태코드는 3XX
- Location응답 헤더는 콘텐츠의 새로운 선호하는 위치에 대한 URI를 포함

***영구히 리소스가 옮겨진 경우***

- 클라이언트에게 리소스 이름이 바뀌었으므로 북마크를 갱신하라고 전달.
- 301 Moved Permanently 상태코드 사용

***임시로 리소스가 옮겨진 경우***

- 클라이언트에게 임시적으로 바뀌었으니, 이후에도 원래 URL로 찾아오고 북마크도 갱신하지 않으라고 전달
- 303 See Other, 307 Temporary Redirect 상태코드 사용

***URL 증강***

- 문맥 정보를 포함시키기 위해 재 작성된 URL로 리다이렉트
- 클라이언트는 리다이렉트를 따라가, 상태정보가 추가된 완전한 URL을 포함한 요청을 재 전송
- 트랜잭션간 상태를 유지하는 유용한 방법
- 303 See Other, 307 Temporary Redirect 상태코드 사용

***부하 균형***

- 과부화된 서버가 요청을 받으면, 덜 부하가 걸리는 서버로 리다이렉트
- 303 See Other, 307 Temporary Redirect 상태코드 사용

***친밀한 다른 서버가 있을 때***

- 웹 서버가 사용자에 대한 정보를 갖는 다른 서버로 리다이렉트 할 수 있음
- 303 See Other, 307 Temporary Redirect 상태코드 사용

***디렉터리 이름 정규화*** 

- 클라이언트가 디렉터리 이름에 대한 URI를 요청 하는데에 `/` 을 빠뜨렸다면, 상대적 경로가 정상적으로 동작할 수 있도록 클라이언트에 슬래시를 추가한 URI로 리다이렉트

## 5.9 단계 6: 응답 보내기

- 응답 전송시 요청 수신과 비슷한 이슈에 직면.
    - 여러 클라이언트에 대한 여러 커넥션이 있고, 각 상태가 다양함
- 서버는 커넥션 상태를 추적해, 지속적인 커넥션은 특별히 주의해서 다뤄야 함
    - 비지속 커넥션이라면 메시지 전송 후 커넥션을 닫음
- 지속적인 커넥션은, Content-Length 헤더를 바르게 계산하기위해 특별한 주의를 필요로 하는 경우나, 클라이언트가 언제 끝나는지 알 수 없는 경우(4장 참조)에, 열린 상태 유지

## 5.10 단계 7: 로깅

- 트랜잭션 완료 후, 어떻게 수행 되었는지 로그 파일에 기록.
- 대부분의 웹서버는 로깅에 대한 여러가지 설정양식 제공.
- 자세한 내용은 21장