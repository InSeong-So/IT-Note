# 운영체제

## 목차
1. [운영체제 개요](#운영체제-개요)
   - [운영체제 정의](#운영체제-정의)
   - [시스템 호출](#시스템-호출)
   - [커널과 인터페이스](#커널과-인터페이스)
   - [커널의 종류](#커널의-종류)
2. [가상화 기술](#가상화-기술)
   - [가상머신](#가상머신)
   - [하이퍼바이저](#하이퍼바이저)
   - [컨테이너 vs 가상머신](#컨테이너-vs-가상머신)
3. [하드웨어 아키텍처](#하드웨어-아키텍처)
   - [CPU vs GPU](#cpu-vs-gpu)
   - [메모리 구성](#메모리-구성)
   - [메모리 종류 (RAM vs ROM)](#메모리-종류-ram-vs-rom)
   - [메모리 계층](#메모리-계층)
4. [메모리 관리](#메모리-관리)
   - [메모리 관리 전략](#메모리-관리-전략)
   - [메모리 할당 알고리즘](#메모리-할당-알고리즘)
   - [가상 메모리](#가상-메모리)
   - [페이징 기법](#페이징-기법)
     - [페이징 기법 개념](#페이징-기법이란-무엇인가요)
     - [주소 변환 과정](#페이징-기법의-주소-변환-과정에-대해-설명해주세요)
     - [페이징 테이블 관리](#페이징-테이블은-어떻게-관리하나요)
     - [페이지 테이블 매핑 방식](#페이지-테이블의-매핑-방식을-설명해주세요)
     - [요구 페이징](#요구-페이징은-무엇인가요)
     - [페이지 테이블 엔트리 구조](#페이지-테이블-엔트리의-구조에-대해-알려주세요)
     - [페이지 부재](#페이지-부재를-설명해주세요)
     - [지역성](#지역성이란-무엇인가요)
   - [페이지 교체 알고리즘](#페이지-교체-알고리즘)
     - [페이지 교체 알고리즘 개요](#페이지-교체-알고리즘은-무엇이고-어떤-종류가-있죠)
     - [무작위 페이지 교체](#무작위-페이지-교체-알고리즘을-알려주세요)
     - [FIFO 페이지 교체](#fifo-페이지-교체-알고리즘을-알려주세요)
     - [최적 페이지 교체](#최적-페이지-교체-알고리즘을-알려주세요)
     - [LRU 페이지 교체](#lru-페이지-교체-알고리즘을-알려주세요)
     - [LFU 페이지 교체](#lfu-페이지-교체-알고리즘을-알려주세요)
     - [NUR 페이지 교체](#nur-페이지-교체-알고리즘을-알려주세요)
     - [FIRO 변형 알고리즘](#firo-변형-알고리즘을-알려주세요)
   - [캐시와 버퍼](#캐시와-버퍼)
5. [프로세스와 스레드](#프로세스와-스레드)
   - [프로세스 기본 개념](#프로세스-기본-개념)
   - [프로세스 동기화](#프로세스-동기화)
   - [스레드 개념](#스레드-개념)
   - [멀티프로세싱 vs 멀티스레딩](#멀티프로세싱-vs-멀티스레딩)
6. [CPU 스케줄링](#cpu-스케줄링)
   - [스케줄링 개념](#스케줄링-개념)
   - [스케줄링 알고리즘](#스케줄링-알고리즘)
   - [병렬 처리](#병렬-처리)
7. [동기화와 교착상태](#동기화와-교착상태)
   - [임계구역 문제](#임계구역-문제)
   - [동기화 기법](#동기화-기법)
   - [교착상태](#교착상태)
8. [파일 시스템과 입출력](#파일-시스템과-입출력)
   - [파일 시스템](#파일-시스템)
   - [디스크 스케줄링](#디스크-스케줄링)
   - [RAID](#raid)
9. [분산 시스템과 클라우드](#분산-시스템과-클라우드)
   - [분산 시스템](#분산-시스템)
   - [클라이언트/서버 시스템](#클라이언트서버-시스템)
   - [P2P 시스템](#p2p-시스템)
   - [클라우드 컴퓨팅](#클라우드-컴퓨팅)
10. [마이크로서비스 아키텍처](#마이크로서비스-아키텍처)
    - [특징과 장단점](#특징과-장단점)
    - [vs 모놀리식 아키텍처](#vs-모놀리식-아키텍처)
11. [보안과 성능](#보안과-성능)
    - [운영체제 보안](#운영체제-보안)
    - [성능 모니터링](#성능-모니터링)
    - [최적화 기법](#최적화-기법)
12. [최신 동향과 기술](#최신-동향과-기술)
    - [컨테이너 오케스트레이션](#컨테이너-오케스트레이션)
    - [서버리스 컴퓨팅](#서버리스-컴퓨팅)
    - [엣지 컴퓨팅](#엣지-컴퓨팅)
    - [동시성과 병렬성](#동시성과-병렬성)
13. [DevOps와 인프라](#devops와-인프라)
    - [인프라 as 코드(IaC)](#인프라-as-코드iac)
    - [CI/CD 파이프라인](#cicd-파이프라인)
    - [관찰 가능성(Observability)](#관찰-가능성observability)

---

## 운영체제 개요

### 운영체제 정의
> 운영체제는 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어입니다.

운영체제는 인터페이스(GUI)와 시스템 호출(System call), 커널(Kernel)과 드라이버(Driver)로 구성됩니다. 이 중 **사용자와 응용 프로그램에 인접하여 커널에 명령을 전달하고 실행 결과를 사용자와 응용 프로그램에 돌려주는 인터페이스**와 **운영 체제의 핵심 기능을 모아놓은 커널**로 구분됩니다.

#### 📋 운영체제의 역할과 목적
- **효율적인 자원 관리**: CPU, 메모리, 저장장치 등 시스템 자원의 효율적 배분과 관리
- **안정적인 자원 보호**: 프로세스 간 자원 충돌 방지 및 보안 유지
- **확장성 높은 하드웨어 인터페이스 제공**: 다양한 하드웨어와의 호환성 보장
- **편리한 사용자 인터페이스 제공**: 사용자와 시스템 간의 효율적인 상호작용 지원

#### 📋 현대 운영체제의 특징
- **멀티태스킹**: 여러 프로그램의 동시 실행
- **멀티유저**: 다수 사용자의 동시 접근 지원
- **분산 처리**: 네트워크를 통한 자원 공유
- **실시간 처리**: 시간 제약이 있는 작업의 처리
- **플러그 앤 플레이**: 하드웨어 자동 인식 및 설정

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

### 시스템 호출
> 시스템 호출(System call)은 커널이 자신을 보호하기 위해 만든 인터페이스입니다.

커널은 보안을 위해 사용자나 응용 프로그램이 자원에 직접 접근하는 것을 차단하므로 자원을 이용 하려면 시스템 호출이라는 인터페이스를 이용해야 합니다.

**커피를 마시기 위해 준비하는 과정**을 예를 들어볼까요? 우리는 커피를 만들기 위해서 커피머신과 재료를 찾고, 이를 조제하여 마십니다. 그러기 위해서는 재료를 구비하고 커피머신의 사용법을 명확히 알아야 하죠. 이 과정 중 커피머신이 망가지거나 더러워질 수 있습니다.

반면 카페에서 커피를 주문한다고 생각해봅시다. 위의 번거로운 과정을 겪지 않아도 되는 것이죠! 이것이 직접 접근(사용자가 컴퓨터 자원에 직접 접근하여 작업)과 시스템 호출(작업을 요청하고 결과만 전달)입니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `커널`과 `인터페이스`의 설명을 부탁드립니다.
> 커널(kernel)은 운영체제의 핵심 기능을 모아놓은 것이며, 인터페이스(interface)는 사용자와 응용 프로그램에 인접해 커널에 명령을 전달하고 실행 결과를 반환합니다.

<br>

<div align='center'>

<img src='./img/kernel_interface.jpg' width='400'/>

</div>

<br>

커널은 `프로세스, 메모리, 저장장치 관리와 같이 운영체제의 핵심적인 기능을 모아놓은 것`으로 자동차에 비유하자면 엔진에 해당합니다. 마치 벤츠, 테슬라, 아우디의 성능을 엔진이 좌우하는 것처럼 운영체제의 성능은 이 커널에 달려 있습니다. 이러한 커널의 주요 역할은 아래와 같습니다.

|핵심 기능|설명|
|--------|----|
|프로세스 관리|프로세스에 CPU 배분 및 필요한 작업 환경 제공|
|메모리 관리|프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간 제공|
|파일 시스템 관리|데이터 저장 및 접근 가능한 인터페이스 제공|
|입출력 관리|필요한 입출력 서비스 제공|
|프로세스 간 통신 관리|공동 작업을 위한 프로세스 간 통신 환경 지원|

> 프로세스 간 통신(Inter-Process Communication, IPC)

<br>

자동차는 사람이 조작이 가능해야 하죠? 핸들과 브레이크, 계기판 등으로 확인하거나 행위에 대해 변경할 수 있어야 하죠. 운영체제의 인터페이스는 `커널에 사용자 명령을 전달하고, 실행 결과를 사용자에게 알려주는 역할`을 해요. 응용 프로그램과 커널의 인터페이스는 **시스템 호출**, 커널과 하드웨어의 인터페이스는 **드라이버**가 담당합니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: 커널의 `종류`를 알려주세요.
> 커널의 핵심 기능은 유기적으로 복잡하게 얽혀 있습니다.

### 단일형 구조 커널
> 단일형 구조(Monolithic Architecture) 커널은 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어 있습니다.

<br>

<div align='center'>

<img src='./img/monolithic_architecture.jpg' width='600'/>

</div>

<br>

초기에는 기능을 만들기에 바빴으므로 모듈을 분리하여 구현할 여유가 없었습니다. 프로그래밍 언어의 함수로 비유하자면 main() 함수에 모든 기능을 탑재한 것이에요.

그런 만큼 모듈 간 통신 비용이 줄어들어 `효율적인 운영이 가능`했습니다. 그러나 `버그나 오류에 대처하기 힘들었으며` 하나의 에러가 `시스템 전체에 영향`을 미치고, `다양한 환경의 시스템에 적용하기 어려워` 현대의 운영체제에 단일형 구조 커널을 구현하기는 쉽지 않았습니다.

<br>

### :book: 계층형 구조 커널
> 계층형 구조(Layered Architecture) 커널은 비슷한 기능을 가진 모듈을 묶어 하나의 계층으로 만들고 계층 간 통신을 통해 운영체제를 구현합니다.

<br>

<div align='center'>

<img src='./img/layered_architecture.jpg' width='600'/>

</div>

<br>

단일형 구조 커널을 발전한 형태입니다. 기능을 분류하여 모아놓음으로 `버그나 오류를 쉽게 처리`할 수 있었죠. 오류가 발생하면 전체 커널이 아니라 해당 계층만 수정하면 되어 `디버깅(Debugging)도 쉬웠`습니다. 오늘날의 운영체제는 대부분 이 구조로 이루어져 있습니다.

<br>

### :book: 마이크로 구조 커널
> 마이크로 구조(Micro Architecture) 커널은 운영체제가 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공합니다.

<br>

<div align='center'>

<img src='./img/micro_architecture.jpg' width='600'/>

</div>

<br>

하드웨어와 사용자의 요구가 다양해짐에 따라 커널의 계층과 기능도 커져만 갔습니다. 하드웨어의 용량과 커널의 크기가 지나치게 방대해지면서 오류를 잡기 힘들었죠. 따라서 계층형 구조의 접근 방식과 반대인 마이크로 구조 커널이 등장하게 되었습니다.

마이크로 구조 커널은 기본적인 기능만 제공합니다. 모듈은 세분화 되어 존재하지만 모듈 간 정보 교환은 프로세스 간 통신을 이용해 이루어집니다.

마이크로 구조 커널은 각 모듈이 독립적으로 작동하므로 `하나의 모듈에 에러가 발생해도 운영체제가 멈추지 않습니다`. 또한 `다양한 컴퓨터에 이식이 쉽고` `커널이 가벼워 CPU 용량이 작은 시스템에도 적용이 가능`합니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `가상머신`이란 무엇인가요?
> 가상 머신(Virtual Machine, VM)은 물리적 하드웨어 시스템에 구축되어 자체 CPU, 메모리, 네트워크 인터페이스 및 스토리지를 갖춘 가상 환경입니다.

커널 기반 가상 머신(KVM)과 같은 하이퍼바이저가 탑재된 물리적 머신을 호스트 머신, 호스트 컴퓨터, 호스트 운영 체제 또는 간단히 호스트라고 부릅니다. 리소스를 사용하는 여러 VM을 게스트 머신, 게스트 컴퓨터, 게스트 운영 체제 또는 간단히 게스트라고 부릅니다. 하이퍼바이저는 CPU, 메모리, 스토리지 등의 컴퓨팅 리소스를 처리하는 리소스의 풀로, 기존 게스트 간 또는 새로운 가상 머신에 쉽게 재배치할 수 있습니다.

VM은 시스템의 나머지 부분과 격리되며, 서버처럼 하나의 하드웨어에 여러 VM이 존재할 수 있습니다. 이는 수요에 따라 또는 더 효율적인 리소스 사용을 위해 호스트 서버 간에 이동할 수 있습니다.  

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `하이퍼바이저`란 무엇인가요?
> 가상 머신을 생성하고 구동하는 소프트웨어입니다.

가상 머신 모니터(Virtual Machine Monitor, VMM)라고도 불리는 하이퍼바이저는 하이퍼바이저 운영 체제와 가상 머신의 리소스를 분리해 VM의 생성과 관리를 지원합니다.

하이퍼바이저로 사용되는 물리 하드웨어를 호스트라고 하며 리소스를 사용하는 여러 VM을 게스트라고 합니다.

하이퍼바이저는 CPU, 메모리, 스토리지 등의 리소스를 처리하는 풀로, 기존 게스트 간 또는 새로운 가상 머신에 쉽게 재배치할 수 있습니다.

모든 하이퍼바이저에서 VM을 실행하려면 메모리 관리 프로그램, 프로세스 스케줄러, I/O(입력/출력) 스택, 기기 드라이버, 보안 관리 프로그램, 네트워크 스택과 같은 운영 체제 수준의 구성 요소가 필요합니다.

하이퍼바이저는 할당되었던 리소스를 각 가상 머신에 제공하고, 물리 리소스에 대해 VM 리소스의 일정을 관리합니다. 물리적 하드웨어는 계속해서 실행 작업을 수행하므로 하이퍼바이저가 일정을 관리하는 동안 CPU가 VM에서 요청한 대로 CPU 명령을 계속 실행합니다.

서로 다른 여러 개의 운영 체제를 나란히 구동할 수 있으며, 하이퍼바이저를 사용해 동일한 가상화 하드웨어 리소스를 공유합니다. 바로 이러한 부분이 가상화의 핵심적인 이점입니다. 가상화가 없다면 하드웨어에서 운영 체제를 1개만 구동할 수 있습니다. 

컨테이너와 VM은 유사하다고 볼 수 있습니다. 이 두 가지 모두 다양한 IT 요소를 결합해 시스템의 나머지 부분으로부터 분리하는 패키지 컴퓨팅 환경이기 때문입니다. 중요한 차이점은 확장 방식과 이식성

<br>

<p>[참조] <a href="https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor">CPU와 GPU의 차이</a></p>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `GPU`와` CPU`의 차이에 대해 설명하세요.
> 둘 다 실리콘 기반 마이크로프로세서로 데이터를 처리할 수 있으나 아키텍쳐와 용도가 다릅니다.

CPU는 최상위 계층의 '중앙처리장치'로써 컴퓨터의 두뇌와 같은 역할을 담당합니다. 따라서 데이터 처리와 더불어 프로그램에서 분석한 알고리즘에 따라 다음 행동을 결정하고 멀티태스킹을 위해 나눈 작업들에 우선순위를 지정하고 전환하며 가상 메모리를 관리하는 등 컴퓨터를 지휘하는 역할을 수행합니다.

GPU는 픽셀로 이루어진 영상을 처리하는 용도로 탄생했습니다. 반복적이고 비슷한 대량 연산을 병렬적(Parallel)으로 수행하기 때문에 CPU보다 훨씬 빠릅니다. 영상, 렌더링을 비롯한 그래픽 작업의 경우 픽셀 하나하나에 대해 연산을 하기 때문에 연산능력이 비교적 떨어지는 CPU가 GPU로 데이터를 보내 재빠르게 처리합니다.

CPU는 GPU보다 적은 코어를 갖고 있지만 각 코어가 GPU보다 강력하므로 순차 작업(Sequential task)에 좋습니다. 반면 GPU는 병렬 작업을 효율적으로 처리할 수 있는 수천 개의 코어를 가지므로병렬 작업(Paralell task)에 좋습니다.

애플리케이션의 연산 집약적 부분을 GPU로 넘기고 나머지 코드만을 CPU에서 처리하는 GPU 가속 컴퓨팅은 딥러닝, 머신러닝 영역에서 강력한 성능을 제공합니다. 사용자 입장에서는 연산 속도가 놀라울 정도로 빨라졌음을 느낄 수 있죠.

<br>

<p>[참조] <a href="https://sdc-james.gitbook.io/onebook/2.-1/1./1.1.1.-cpu-gpu">CPU와 GPU의 차이</a></p>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `메모리의 구성`에 대해 설명해주세요.
> 메모리는 코드, 데이터, 스택, 힙 영역으로 나누어져 있습니다.

| 영역          | 설명                                                                                                              |
| ------------- | ----------------------------------------------------------------------------------------------------------------- |
| `코드` 영역   | 실행될 프로그램의 코드가 저장됩니다.                                                                              |
| `데이터` 영역 | 전역 변수와 정적 변수가 저장됩니다.                                                                               |
| `스택` 영역   | 지역변수와 매개 변수가 저장되어 있으며, 함수의 호출과 함께 할당<br>컴파일 타임(Compile time)에 크기가 결정됩니다. |
| `힙` 영역     | 사용자에 의해 동적으로 할당되고 해제될 수 있는 메모리 영역<br>런 타임(Run time)에 크기가 결정됩니다.              |

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: 메모리의 종류인 `RAM` 과 `ROM` 에 대해 알려주세요.
### RAM(Random Access Memory)
> 임의 액세스 방식의 반도체 집적회로 기억장치(Semiconductor IC Memory)입니다.

데이터 읽기와 쓰기가 모두 가능하나 휘발성(Volatile)으로서 전원 공급이 중단되면 내용이 삭제됩니다. 종류로는 용량이 큰 주기억장치로 사용되는 DRAM(Dynamic RAM)과 DRAM 보다 처리 속도가 빨라 캐시 기억장치로 사용되는 SRAM(Static RAM)이 있습니다.

<br>

### ROM(Read Only Memory)
> 영구 저장이 가능한 반도체 기억장치로 읽는 것만 가능하며 쓰는 것은 불가능합니다.

보통 시스템 초기화 및 진단 프로그램이나 자주 쓰는 함수들로 구성된 서브루틴에 사용합니다. 종류로는 사용자가 한 번 쓰는 것이 가능한 PROM(Programmable ROM),  자외선을 이용하여 내용을 지우는 것이 가능한 PROM 형태인 EPROM(Erasable Programmable ROM), 전기적으로 데이터를 지울 수 있는 EEPROM(Electrically Erasable PROM), 블록 단위로 지우는 것이 가능한 플래쉬 기억장치(Flash Memory)가 있습니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `메모리 계층`에 대해 알려주세요.
> 메모리 계층(Memory hierarchy)는 CPU가 메모리에 더욱 빠르게 접근하기 위해 나눈 구조입니다.

<br>

<div align=center>

<img src="img/Memory_Hierarchy.jpg" alt="Memory_Hierarchy" width="400"/>

</div>

<br>

이를 설명하자면, 아래와 같습니다.
1. 레지스터와 캐시는 CPU 내부에 존재하므로 CPU는 아주 빠르게 접근할 수 있습니다.
2. 메모리는 CPU 외부에 존재하므로 레지스터와 캐시보다 더 느리게 접근 할 수 밖에 없습니다.
3. 하드 디스크는 CPU가 직접 접근할 방법이 없습니다. 따라서 CPU는 하드 디스크의 데이터를 메모리로 이동시키고, 이 메모리에서 접근하므로 속도가 아주 느립니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `메모리 관리 전략`에 대해 알려주세요.
> 메모리는 CPU 가 직접 접근하는 유일한 저장장치입니다.

메모리 시스템(하드웨어)은 주소(메모리 위치)를 관리하며 할당과 접근을 제어하는데, 이는 `제한된 물리적 메모리의 효율적인 사용(할당)`과 `효율적인 메모리 참조(논리-물리주소 할당)`를 위함입니다.

이러한 관리에는 여러 전략이 있습니다.
1. **스와핑(Swapping)** : CPU에서 실행 중이지 않은 프로세스의 메모리 이미지를 저장 장치에 이동시켜 메모리 사용의 효율성을 증가시킵니다.
2. **연속 메모리 할당(Contiguous Memory Allocation)** : 각 프로세스가 필요로 하는 메모리 요구량을 분석한 뒤, 필요한 메모리를 연속으로 할당(연속된 물리 메모리이므로 시작 주소만 필요해요)합니다.
3. **페이징(Paging)** : 프로세스가 사용하는 주소 공간을 여러 개로 분할하여 비연속적인 물리 메모리 공간에 할당, 가상 메모리를 모두 같은 크기의 블록으로 편성합니다.
4. **세그멘테이션(Segmentation)** : 프로세스가 필요로 하는 메모리 공간을 분할하여 비연속적인 물리 메모리 공간에 할당합니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `메모리 할당 알고리즘`에 대해 알려주세요.
> 새로 적재되어야 할 데이터를 주기억장치 영역 중 어느 곳에 배치할지를 결정하는 전략입니다.

페이지, 세그먼트 등이 적재될 위치를 결정하는 정책으로, 종류는 아래와 같습니다.
1. **최초 적합(First-fit)** : 가용공간 중 수용가능한 첫번째 기억공간을 할당합니다.
2. **최적 적합(Best-fit)** : 모든 공간 중에서 수용가능한 가장 작은 곳을 선택합니다.
3. **최악 적합(Worst-fit)** : 모든 공간 중에서 수용가능한 가장 큰 곳을 선택합니다.

따라서, **공간 효율성**은 `최적 적합 > 최초 적합 > 최악 적합` 순으로, **시간 효율성**은 `최초 적합 > 최적적합 ≒ 최악적합` 순이 됩니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `페이지 교체 알고리즘`에 대해 알려주세요.
> 페이지 부재 발생 시 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할 지를 결정하는 전략입니다.

여러 종류가 있는데, 하나씩 간단히 살펴봅시다.
1. **FIFO(First-In, First-Out)** : 메모리에 올라온 지 가장 오래된 페이지를 교체합니다.
2. **최적 페이지 교체(Optimal Page Replace)** :	이론상 최적 알고리즘입니다.
3. **NRU 페이지 교체(Not-Recently-Used)**: 최근 미사용 페이지를 교체합니다.
4. **LRU 페이지 교체(Least-Recently-Used)** : 가장 오래 사용되지 않은 페이지를 교체합니다.
5. **LFU 페이지 교체(Least-Frequently-Used)** : 참조 횟수가 가장 작은 페이지를 교체합니다.
6. **MFU 페이지 교체(Most-Frequently-Used)** : 참조 횟수가 가장 많은 페이지를 교체합니다.

<br>

- ~~랜덤 페이지 교체~~ 잘 사용되지 않습니다.
- ~~2차 기회 : Second Chance. FIFO의 변형판~~ 잘 사용되지 않습니다.
- ~~클럭~~ 잘 사용되지 않습니다.
- ~~에이징~~ 잘 사용되지 않습니다.
- ~~참조 비트 없는 하드웨어 기법~~ 잘 사용되지 않습니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `가상 메모리`에 대해 설명해주세요.
> 가상 메모리(Virtual Memory)는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술입니다.

물리적으로 존재하지는 않으나 사용자에게 있어 메모리의 역할을 하는 가상의 메모리로 운영체제가 발전하면서 실제 메모리를 더 효율적으로 사용하기 위해 파생된 기법입니다.

프로그램은 가상 메모리의 크기에 맞춰 수용되지만 수용된 프로그램 실행 시 실제 메모리가 필요합니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: 가상 메모리의 `매핑 테이블`은 무엇인가요?
> 가상 주소는 실제 물리 주소 혹은 스왑 영역 중 한 곳에 위치하고, 메모리 관리자는 가상 주소와 물리 주소를 1:1 매핑 테이블(Mapping Table)로 관리합니다.

사용 가능한 메모리 주소는 적은데 대기하는 프로세스가 많다고 가정해볼까요? 보통 프로세스가 접근하는 순서대로 메모리 주소를 할당하지만, 가끔은 우선순위에 따라 프로세스 순서를 바꾸기도 하죠. 매 순간 프로세스의 메모리 할당과 실행을 관리하는 가장 좋은 방법은 `테이블 형태`로 관리하는 것이며, 이를 매핑 테이블이라고 합니다.

매핑 테이블에는 프로세스가 접근하는 순서, 작업의 양, 현재 주소, 실행할 내용 등이 있죠. 이 매핑 테이블을 메모리 관리자가 공유하면서 프로세스를 처리하면 작업 효율이 올라가겠죠?

아래 그림은 매핑 테이블을 나타낸 것입니다.

<br>

<div align=center>

<img src="img/mapping_table.jpg" alt="Process" width="500"/>

</div>

<br>

가상 주소상 프로세스 A는 물리 메모리의 세그먼트 0에, 프로세스 B는 세그먼트 1에 위치합니다. 그럼 프로세스 D는 뭘까요? 바로 스왑 영역입니다. A가 원할 때는 세그먼트 0에서 원하는 데이터를 가져오기만 하면 되는 형태가 되는 것이죠.

매핑 테이블은 페이징 기법에서는 페이지 매핑 테이블(Page Mapping Table), 세그멘테이션 기법에서는 세그멘테이션 매핑 테이블(Segmentation Mapping Table)이라고 부릅니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `버퍼`가 무엇인지 알려주세요.
> 버퍼(Buffer)는 속도 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할을 합니다.

만약 느린 입출력 장치에서 데이터를 읽을 때마다 하나씩 전송하면 작업량에 비해 실제 전송량은 매우 작죠. 그러나 일정량의 데이터를 모아서 한 번에 전송하면 적은 작업량으로 많은 데이터를 전송할 수 있습니다. 이렇게 일정한 데이터를 모아 옮김으로써 속도의 차이를 완화하는 장치가 버퍼입니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `캐시`란 무엇인가요?
> 캐시(Cache)는 메모리와 CPU 간 속도 차이를 완화하기 위해 메모리 데이터를 미리 가져와 저장해두는 임시 저장소입니다.

캐시는 CPU 내부에 위치하고, CPU 내부 버스 속도로 작동합니다. 메모리의 경우 시스템 버스 속도로 작동하기 때문에 느리죠. 즉 빠른 CPU와 느린 메모리 사이에서 두 장치의 속도 차이를 완화해줍니다.

캐시는 필요한 데이터를 모아 한꺼번에 전달하는 버퍼의 일종으로, CPU가 앞으로 사용할 데이터를 예상하고 미리 가져옵니다. 이러한 작업을 **미리 가져오기(Prefetch)** 라고 합니다.

CPU는 메모리에 접근해야 할 때 캐시를 먼저 방문하여 원하는 데이터가 있는지 찾아볼 수 있죠. 그 데이터가 존재하면 캐시 히트(Cache Hit)라고 하며 이를 바로 사용합니다. 그러나 이 데이터가 없다면 캐시 미스(Cache Miss)라고 하며 메모리에 접근하여 데이터를 찾게 됩니다. 캐시가 히트되는 비율을 캐시 적중률(Cache Hit Ratio)라고 하며, 일반적인 컴퓨터의 캐시 적중률은 약 90%입니다.

<br>

<div align=center>

<img src="img/cache_hit.jpg" alt="Process" width="500"/>

</div>

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `캐시의 지역성`을 설명해주세요.
> 캐시 적중률을 향상시키기 위해 지역성(Locality)의 원리가 사용됩니다.

프로그램이 모든 데이터를 균등하게 접근하거나 비슷한 시간에 참조한다면 캐시 효율이 떨어지게 돼죠. 따라서 접근하는 특정 순간에 집중적으로 참조하는 특성을 지역성이라고 하며 `시간`과 `공간` 지역성이 존재합니다.

- 시간 지역성 : 특정 데이터가 접근되었따면 가까운 미래에 또 한번 데이터에 접근할 가능성이 높습니다.
- 공간 지역성 : 특정 데이터의 주변 주소가 접근되었을 경우입니다. 메모리 주소를 오름차순이나 내림차순으로 접근한다면 캐시에 저장된 같은 블록의 데이터를 접근하게 되므로 캐시의 효율성이 크게 향상됩니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `캐시 메모리` 에 대해 알려주세요.
> CPU와 주기억장치의 속도 차이로 인한 CPU 대기 시간을 최소화시키기 위해 설치하는 고속 반도체 기억장치입니다.

CPU 와 주기억장치 사이에 설치되며 주기억장치보다 액세스 속도가 높은 칩을 사용하지만 공간이 제한되므로 용량이 적고, 가격이 너무 비쌉니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: 캐시 메모리의 `사상 방식` 에 대해 알려주세요.
> 매핑(Mapping)과 동일한 말입니다. 페이지 테이블 매핑 방식과 비슷하게 사용되지만 캐시의 크기는 메모리보다 작아 항상 메모리의 일부 페이지만 가지고 있죠.

### 캐시 직점 매핑
> 메모리의 페이징 방식과 마찬가지로 캐시도 메모리를 일정 크기로 나누지만, 명확히 다릅니다!

페이지 테이블의 직접 매핑에서는 물리 메모리에 **모든 페이지 테이블**을 가지고 있으나 캐시의 직접 매핑에서는 캐시된 데이터가 매번 같은 자리로 올라오기 때문에 **캐시 테이블 전체를 찾아보지 않아도** 캐시 히트나 캐시 미스를 바로 알 수 있습니다.

캐시 직접 매핑의 장점은 메모리의 페이지가 캐시의 같은 위치에 올라오므로 태그만 확인하면 캐시 히트나 캐시 미스를 빠르게 확인할 수 있다는 것입니다. 그러나 동일한 이유로 자리 다툼이 발생한다는 단점도 가집니다. 캐시에 여유가 있어도 같은 위치만 사용해야 하기 때문에 캐시 적중률이 떨어지는데 이런 문제를 완화하는 방법이 연관 매핑입니다.

<br>

### 캐시 연관 매핑
> 캐시 연관 매핑은 메모리의 페이지 테이블 연관 매핑과 동일합니다.

메모리 워드가 캐시의 어느 위치에도 자유롭게 올라가므로 캐시가 메모리 워드의 주소를 전부 가지고 있습니다. CPU가 특정 주소를 필요로 할 때 캐시에서 검색하여 찾는 경우 캐시 히트, 찾지 못하면 캐시 미스가 발생하여 메모리에서 원하는 데이터를 가져옵니다.

즉, 연관 매핑은 캐시 메모리를 자유롭게 사용할 수 있다는 것이 장점이지만 캐시 히트인지, 미스인지 확인하기 위해 모든 캐시 주소를 검색해야 한다는 단점도 있죠. 따라서 **연관 매핑은 직접 매핑보다 느립니다**.

<br>

### 캐시 집합-연관 매핑
> 직접 매핑과 연관 매핑의 장점만 취한 방식입니다.

캐시 메모리를 K개의 집합으로 나누고 **각 집합에 직접 매핑을 사용**합니다. 그러면 같은 끝자리를 가진 캐시 메모리가 K개가 되므로 직접 매핑의 자리 다툼 문제가 완화됩니다. 또한 집합 내에서 직접 매핑을 사용하기때문에 연관 매핑처럼 모든 캐시를 뒤지는 일 없이 바로 캐시 히트 여부를 알 수 있습니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `저장장치의 계층 구조`에 대해 설명할 수 있나요?
> 저장장치 계층 구조(Storage Hierarchy)는 사용자가 저렴한 가격으로 용량은 하드디스크처럼, 작업 속도는 레지스터처럼 사용하게 해줍니다.

최고 성능의 컴퓨터를 제작하기 위해 SSD를 장착하고 메모리를 확장하고, 캐시 적중률을 높이는 것은 너무 비쌉니다.

그래서 가격과 컴퓨터 성능 사이에 타협점이 존재하는데, 이것이 저장장치의 계층 구조입니다. 

<br>

<div align='center'>

<img src='./img/storage_hierarchy.jpg' width='600'/>

</div>

<br>

이 저장장치 계층 구조는 속도가 빠르고 비싼 저장장치(레지스터, 캐시)를 CPU와 가까운 쪽에, 값이 싸고 용량이 큰 저장장치(하드디스크)는 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 동시에 얻을 수 있습니다.

그러나 이 구조도 문제가 있죠. 바로 데이터 일관성을 유지하는 것입니다. CPU가 캐시에 저장된 데이터를 변경하면 메모리의 데이터도 갱신되어야 하지만 즉시 반영되지 않고 지연 쓰기를 한다면 일관성에 문제가 생기죠. 또한 다른 작업이 현재 작업의 데이터를 읽어도 일관성이 깨지며, 전원이 꺼지면 데이터를 손실할 수도 있습니다.

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트`의 개념을 설명해주세요.
> CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우 CPU에게 알려서 처리할 수 있도록 하는 기술입니다.

### 📋 인터럽트의 목적
- **비동기 처리**: CPU가 다른 작업을 하면서도 중요한 이벤트에 즉시 반응
- **효율성 향상**: 폴링(Polling) 방식의 비효율성 해결
- **우선순위 처리**: 긴급한 작업을 즉시 처리
- **멀티태스킹**: 여러 프로세스의 동시 실행 지원

### 📋 인터럽트 발생 원인
- **하드웨어 인터럽트**: 키보드, 마우스, 타이머, 네트워크 카드 등
- **소프트웨어 인터럽트**: 시스템 콜, 예외(Exception)
- **내부 인터럽트**: 0으로 나누기, 오버플로우 등
- **외부 인터럽트**: 전원 장애, 리셋 신호 등

### 📋 인터럽트 처리 과정
1. **인터럽트 발생**: 하드웨어나 소프트웨어에서 인터럽트 신호 발생
2. **현재 상태 저장**: 레지스터, 프로그램 카운터 등을 스택에 저장
3. **인터럽트 벡터 확인**: 인터럽트 종류에 따른 핸들러 주소 확인
4. **인터럽트 핸들러 실행**: 해당 인터럽트 처리 루틴 실행
5. **원래 상태 복원**: 저장된 상태를 복원하고 원래 프로그램 계속 실행

### 📋 인터럽트 우선순위
- **전원 장애**: 최고 우선순위
- **기계 검사**: 하드웨어 오류
- **외부 신호**: I/O 디바이스
- **입출력**: 입출력 완료 신호
- **프로그램 검사**: 프로그램 실행 중 오류
- **감시 호출**: 시스템 콜

### 📋 인터럽트의 장점
- **빠른 응답**: 중요한 이벤트에 즉시 반응
- **CPU 효율성**: 대기 시간 없이 다른 작업 수행
- **실시간 처리**: 시간에 민감한 작업 처리
- **시스템 안정성**: 오류 상황에 대한 신속한 대응

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `동기적/비동기적 인터럽트`에 대해 알려주세요.
> 인터럽트 발생 시점과 처리 방식에 따른 분류입니다.

### 📋 동기적 인터럽트 (Synchronous Interrupt)
- **정의**: 현재 실행 중인 명령어와 관련하여 발생하는 인터럽트
- **발생 시점**: 명령어 실행 중 예측 가능한 시점
- **예외(Exception)**: 동기적 인터럽트의 다른 이름
- **처리**: 현재 실행 흐름과 동기화되어 처리

#### 동기적 인터럽트 종류
- **Fault**: 수정 가능한 오류 (페이지 부재, 세그멘테이션 오류)
- **Trap**: 의도적인 예외 (시스템 콜, 브레이크포인트)
- **Abort**: 치명적 오류 (하드웨어 오류, 복구 불가능한 오류)

### 📋 비동기적 인터럽트 (Asynchronous Interrupt)
- **정의**: 현재 실행 중인 프로그램과 무관하게 외부에서 발생
- **발생 시점**: 예측 불가능한 임의의 시점
- **외부 인터럽트**: 하드웨어 인터럽트라고도 함
- **처리**: 현재 실행과 독립적으로 처리

#### 비동기적 인터럽트 종류
- **I/O 인터럽트**: 입출력 장치 완료 신호
- **타이머 인터럽트**: 일정 시간 간격으로 발생
- **전원 인터럽트**: 정전, 전압 이상 등
- **외부 신호**: 리셋, 사용자 인터럽트 등

### 📋 처리 방식 비교

| 구분 | 동기적 인터럽트 | 비동기적 인터럽트 |
|------|----------------|------------------|
| **발생 원인** | 프로그램 실행 중 | 외부 하드웨어 |
| **예측 가능성** | 예측 가능 | 예측 불가능 |
| **발생 시점** | 명령어 실행 중 | 임의의 시점 |
| **처리 우선순위** | 즉시 처리 | 현재 명령어 완료 후 |
| **복구 가능성** | 종류에 따라 다름 | 대부분 복구 가능 |

### 📋 인터럽트 마스킹 (Interrupt Masking)
- **정의**: 특정 인터럽트를 일시적으로 차단하는 기능
- **마스킹 가능**: 비동기적 인터럽트 (외부 인터럽트)
- **마스킹 불가능**: 동기적 인터럽트 (예외)
- **용도**: 중요한 작업 중 방해받지 않기 위함

### 📋 실제 적용 예시
- **키보드 입력**: 비동기적 인터럽트 (언제 발생할지 모름)
- **0으로 나누기**: 동기적 인터럽트 (해당 명령어 실행 시)
- **시스템 콜**: 동기적 인터럽트 (프로그램이 의도적으로 호출)
- **네트워크 패킷 도착**: 비동기적 인터럽트

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위에서 실행
- **애플리케이션 실행**: 일반 사용자 프로그램이 실행되는 모드

#### 사용자 모드에서 제한되는 작업
- **I/O 명령어**: 하드웨어 직접 제어
- **메모리 관리**: 페이지 테이블 수정, 메모리 보호 설정
- **인터럽트 제어**: 인터럽트 마스킹, 벡터 테이블 수정
- **특권 레지스터 접근**: 시스템 제어 레지스터

### 📋 커널 모드 (Kernel Mode)
- **최고 권한**: 모든 하드웨어와 시스템 자원에 접근 가능
- **특권 명령어**: 시스템 제어에 필요한 모든 명령어 실행 가능
- **운영체제 실행**: 커널과 시스템 서비스가 실행되는 모드
- **완전한 제어**: 메모리, I/O, 인터럽트 등 모든 시스템 자원 제어

#### 커널 모드에서만 가능한 작업
- **I/O 제어**: 하드웨어 직접 제어 및 드라이버 실행
- **메모리 관리**: 페이지 테이블 관리, 메모리 할당/해제
- **프로세스 관리**: 프로세스 생성, 종료, 스케줄링
- **시스템 호출 처리**: 사용자 요청에 대한 시스템 서비스 제공

### 📋 모드 전환 과정

#### 사용자 모드 → 커널 모드
1. **시스템 콜**: 사용자 프로그램이 시스템 서비스 요청
2. **인터럽트 발생**: 하드웨어 인터럽트 또는 예외 발생
3. **트랩**: 불법적인 명령어 실행 시도
4. **타이머 인터럽트**: 시분할 시스템의 시간 할당 만료

#### 커널 모드 → 사용자 모드
1. **시스템 콜 완료**: 요청된 서비스 처리 완료
2. **인터럽트 처리 완료**: 인터럽트 서비스 루틴 실행 완료
3. **프로세스 스케줄링**: 새로운 사용자 프로세스 선택
4. **예외 처리 완료**: 예외 상황 해결 후 복귀

### 📋 인터럽트와 모드 전환의 관계
- **자동 모드 전환**: 인터럽트 발생 시 자동으로 커널 모드로 전환
- **보안 검사**: 모드 전환 시 권한 및 유효성 검사
- **컨텍스트 저장**: 사용자 모드 상태 정보 저장
- **서비스 제공**: 커널 모드에서 시스템 서비스 제공 후 복귀

### 📋 하드웨어 지원
- **모드 비트**: CPU 내부의 모드 상태를 나타내는 플래그
- **특권 명령어**: 커널 모드에서만 실행 가능한 명령어
- **메모리 보호**: 사용자 모드에서 커널 영역 접근 차단
- **인터럽트 벡터**: 인터럽트 발생 시 커널 모드로 자동 전환

### 📋 실제 구현 예시
- **x86 아키텍처**: Ring 0(커널) ~ Ring 3(사용자) 보호 레벨
- **ARM 아키텍처**: User, Supervisor, IRQ, FIQ 등 다양한 모드
- **RISC-V**: User, Supervisor, Machine 모드
- **운영체제별**: Windows(커널/사용자), Linux(커널/사용자) 모드

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위에서 실행
- **애플리케이션 실행**: 일반 사용자 프로그램이 실행되는 모드

#### 사용자 모드에서 제한되는 작업
- **I/O 명령어**: 하드웨어 직접 제어
- **메모리 관리**: 페이지 테이블 수정, 메모리 보호 설정
- **인터럽트 제어**: 인터럽트 마스킹, 벡터 테이블 수정
- **특권 레지스터 접근**: 시스템 제어 레지스터

### 📋 커널 모드 (Kernel Mode)
- **최고 권한**: 모든 하드웨어와 시스템 자원에 접근 가능
- **특권 명령어**: 시스템 제어에 필요한 모든 명령어 실행 가능
- **운영체제 실행**: 커널과 시스템 서비스가 실행되는 모드
- **완전한 제어**: 메모리, I/O, 인터럽트 등 모든 시스템 자원 제어

#### 커널 모드에서만 가능한 작업
- **I/O 제어**: 하드웨어 직접 제어 및 드라이버 실행
- **메모리 관리**: 페이지 테이블 관리, 메모리 할당/해제
- **프로세스 관리**: 프로세스 생성, 종료, 스케줄링
- **시스템 호출 처리**: 사용자 요청에 대한 시스템 서비스 제공

### 📋 모드 전환 과정

#### 사용자 모드 → 커널 모드
1. **시스템 콜**: 사용자 프로그램이 시스템 서비스 요청
2. **인터럽트 발생**: 하드웨어 인터럽트 또는 예외 발생
3. **트랩**: 불법적인 명령어 실행 시도
4. **타이머 인터럽트**: 시분할 시스템의 시간 할당 만료

#### 커널 모드 → 사용자 모드
1. **시스템 콜 완료**: 요청된 서비스 처리 완료
2. **인터럽트 처리 완료**: 인터럽트 서비스 루틴 실행 완료
3. **프로세스 스케줄링**: 새로운 사용자 프로세스 선택
4. **예외 처리 완료**: 예외 상황 해결 후 복귀

### 📋 인터럽트와 모드 전환의 관계
- **자동 모드 전환**: 인터럽트 발생 시 자동으로 커널 모드로 전환
- **보안 검사**: 모드 전환 시 권한 및 유효성 검사
- **컨텍스트 저장**: 사용자 모드 상태 정보 저장
- **서비스 제공**: 커널 모드에서 시스템 서비스 제공 후 복귀

### 📋 하드웨어 지원
- **모드 비트**: CPU 내부의 모드 상태를 나타내는 플래그
- **특권 명령어**: 커널 모드에서만 실행 가능한 명령어
- **메모리 보호**: 사용자 모드에서 커널 영역 접근 차단
- **인터럽트 벡터**: 인터럽트 발생 시 커널 모드로 자동 전환

### 📋 실제 구현 예시
- **x86 아키텍처**: Ring 0(커널) ~ Ring 3(사용자) 보호 레벨
- **ARM 아키텍처**: User, Supervisor, IRQ, FIQ 등 다양한 모드
- **RISC-V**: User, Supervisor, Machine 모드
- **운영체제별**: Windows(커널/사용자), Linux(커널/사용자) 모드

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위에서 실행
- **애플리케이션 실행**: 일반 사용자 프로그램이 실행되는 모드

#### 사용자 모드에서 제한되는 작업
- **I/O 명령어**: 하드웨어 직접 제어
- **메모리 관리**: 페이지 테이블 수정, 메모리 보호 설정
- **인터럽트 제어**: 인터럽트 마스킹, 벡터 테이블 수정
- **특권 레지스터 접근**: 시스템 제어 레지스터

### 📋 커널 모드 (Kernel Mode)
- **최고 권한**: 모든 하드웨어와 시스템 자원에 접근 가능
- **특권 명령어**: 시스템 제어에 필요한 모든 명령어 실행 가능
- **운영체제 실행**: 커널과 시스템 서비스가 실행되는 모드
- **완전한 제어**: 메모리, I/O, 인터럽트 등 모든 시스템 자원 제어

#### 커널 모드에서만 가능한 작업
- **I/O 제어**: 하드웨어 직접 제어 및 드라이버 실행
- **메모리 관리**: 페이지 테이블 관리, 메모리 할당/해제
- **프로세스 관리**: 프로세스 생성, 종료, 스케줄링
- **시스템 호출 처리**: 사용자 요청에 대한 시스템 서비스 제공

### 📋 모드 전환 과정

#### 사용자 모드 → 커널 모드
1. **시스템 콜**: 사용자 프로그램이 시스템 서비스 요청
2. **인터럽트 발생**: 하드웨어 인터럽트 또는 예외 발생
3. **트랩**: 불법적인 명령어 실행 시도
4. **타이머 인터럽트**: 시분할 시스템의 시간 할당 만료

#### 커널 모드 → 사용자 모드
1. **시스템 콜 완료**: 요청된 서비스 처리 완료
2. **인터럽트 처리 완료**: 인터럽트 서비스 루틴 실행 완료
3. **프로세스 스케줄링**: 새로운 사용자 프로세스 선택
4. **예외 처리 완료**: 예외 상황 해결 후 복귀

### 📋 인터럽트와 모드 전환의 관계
- **자동 모드 전환**: 인터럽트 발생 시 자동으로 커널 모드로 전환
- **보안 검사**: 모드 전환 시 권한 및 유효성 검사
- **컨텍스트 저장**: 사용자 모드 상태 정보 저장
- **서비스 제공**: 커널 모드에서 시스템 서비스 제공 후 복귀

### 📋 하드웨어 지원
- **모드 비트**: CPU 내부의 모드 상태를 나타내는 플래그
- **특권 명령어**: 커널 모드에서만 실행 가능한 명령어
- **메모리 보호**: 사용자 모드에서 커널 영역 접근 차단
- **인터럽트 벡터**: 인터럽트 발생 시 커널 모드로 자동 전환

### 📋 실제 구현 예시
- **x86 아키텍처**: Ring 0(커널) ~ Ring 3(사용자) 보호 레벨
- **ARM 아키텍처**: User, Supervisor, IRQ, FIQ 등 다양한 모드
- **RISC-V**: User, Supervisor, Machine 모드
- **운영체제별**: Windows(커널/사용자), Linux(커널/사용자) 모드

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위에서 실행
- **애플리케이션 실행**: 일반 사용자 프로그램이 실행되는 모드

#### 사용자 모드에서 제한되는 작업
- **I/O 명령어**: 하드웨어 직접 제어
- **메모리 관리**: 페이지 테이블 수정, 메모리 보호 설정
- **인터럽트 제어**: 인터럽트 마스킹, 벡터 테이블 수정
- **특권 레지스터 접근**: 시스템 제어 레지스터

### 📋 커널 모드 (Kernel Mode)
- **최고 권한**: 모든 하드웨어와 시스템 자원에 접근 가능
- **특권 명령어**: 시스템 제어에 필요한 모든 명령어 실행 가능
- **운영체제 실행**: 커널과 시스템 서비스가 실행되는 모드
- **완전한 제어**: 메모리, I/O, 인터럽트 등 모든 시스템 자원 제어

#### 커널 모드에서만 가능한 작업
- **I/O 제어**: 하드웨어 직접 제어 및 드라이버 실행
- **메모리 관리**: 페이지 테이블 관리, 메모리 할당/해제
- **프로세스 관리**: 프로세스 생성, 종료, 스케줄링
- **시스템 호출 처리**: 사용자 요청에 대한 시스템 서비스 제공

### 📋 모드 전환 과정

#### 사용자 모드 → 커널 모드
1. **시스템 콜**: 사용자 프로그램이 시스템 서비스 요청
2. **인터럽트 발생**: 하드웨어 인터럽트 또는 예외 발생
3. **트랩**: 불법적인 명령어 실행 시도
4. **타이머 인터럽트**: 시분할 시스템의 시간 할당 만료

#### 커널 모드 → 사용자 모드
1. **시스템 콜 완료**: 요청된 서비스 처리 완료
2. **인터럽트 처리 완료**: 인터럽트 서비스 루틴 실행 완료
3. **프로세스 스케줄링**: 새로운 사용자 프로세스 선택
4. **예외 처리 완료**: 예외 상황 해결 후 복귀

### 📋 인터럽트와 모드 전환의 관계
- **자동 모드 전환**: 인터럽트 발생 시 자동으로 커널 모드로 전환
- **보안 검사**: 모드 전환 시 권한 및 유효성 검사
- **컨텍스트 저장**: 사용자 모드 상태 정보 저장
- **서비스 제공**: 커널 모드에서 시스템 서비스 제공 후 복귀

### 📋 하드웨어 지원
- **모드 비트**: CPU 내부의 모드 상태를 나타내는 플래그
- **특권 명령어**: 커널 모드에서만 실행 가능한 명령어
- **메모리 보호**: 사용자 모드에서 커널 영역 접근 차단
- **인터럽트 벡터**: 인터럽트 발생 시 커널 모드로 자동 전환

### 📋 실제 구현 예시
- **x86 아키텍처**: Ring 0(커널) ~ Ring 3(사용자) 보호 레벨
- **ARM 아키텍처**: User, Supervisor, IRQ, FIQ 등 다양한 모드
- **RISC-V**: User, Supervisor, Machine 모드
- **운영체제별**: Windows(커널/사용자), Linux(커널/사용자) 모드

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위에서 실행
- **애플리케이션 실행**: 일반 사용자 프로그램이 실행되는 모드

#### 사용자 모드에서 제한되는 작업
- **I/O 명령어**: 하드웨어 직접 제어
- **메모리 관리**: 페이지 테이블 수정, 메모리 보호 설정
- **인터럽트 제어**: 인터럽트 마스킹, 벡터 테이블 수정
- **특권 레지스터 접근**: 시스템 제어 레지스터

### 📋 커널 모드 (Kernel Mode)
- **최고 권한**: 모든 하드웨어와 시스템 자원에 접근 가능
- **특권 명령어**: 시스템 제어에 필요한 모든 명령어 실행 가능
- **운영체제 실행**: 커널과 시스템 서비스가 실행되는 모드
- **완전한 제어**: 메모리, I/O, 인터럽트 등 모든 시스템 자원 제어

#### 커널 모드에서만 가능한 작업
- **I/O 제어**: 하드웨어 직접 제어 및 드라이버 실행
- **메모리 관리**: 페이지 테이블 관리, 메모리 할당/해제
- **프로세스 관리**: 프로세스 생성, 종료, 스케줄링
- **시스템 호출 처리**: 사용자 요청에 대한 시스템 서비스 제공

### 📋 모드 전환 과정

#### 사용자 모드 → 커널 모드
1. **시스템 콜**: 사용자 프로그램이 시스템 서비스 요청
2. **인터럽트 발생**: 하드웨어 인터럽트 또는 예외 발생
3. **트랩**: 불법적인 명령어 실행 시도
4. **타이머 인터럽트**: 시분할 시스템의 시간 할당 만료

#### 커널 모드 → 사용자 모드
1. **시스템 콜 완료**: 요청된 서비스 처리 완료
2. **인터럽트 처리 완료**: 인터럽트 서비스 루틴 실행 완료
3. **프로세스 스케줄링**: 새로운 사용자 프로세스 선택
4. **예외 처리 완료**: 예외 상황 해결 후 복귀

### 📋 인터럽트와 모드 전환의 관계
- **자동 모드 전환**: 인터럽트 발생 시 자동으로 커널 모드로 전환
- **보안 검사**: 모드 전환 시 권한 및 유효성 검사
- **컨텍스트 저장**: 사용자 모드 상태 정보 저장
- **서비스 제공**: 커널 모드에서 시스템 서비스 제공 후 복귀

### 📋 하드웨어 지원
- **모드 비트**: CPU 내부의 모드 상태를 나타내는 플래그
- **특권 명령어**: 커널 모드에서만 실행 가능한 명령어
- **메모리 보호**: 사용자 모드에서 커널 영역 접근 차단
- **인터럽트 벡터**: 인터럽트 발생 시 커널 모드로 자동 전환

### 📋 실제 구현 예시
- **x86 아키텍처**: Ring 0(커널) ~ Ring 3(사용자) 보호 레벨
- **ARM 아키텍처**: User, Supervisor, IRQ, FIQ 등 다양한 모드
- **RISC-V**: User, Supervisor, Machine 모드
- **운영체제별**: Windows(커널/사용자), Linux(커널/사용자) 모드

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위에서 실행
- **애플리케이션 실행**: 일반 사용자 프로그램이 실행되는 모드

#### 사용자 모드에서 제한되는 작업
- **I/O 명령어**: 하드웨어 직접 제어
- **메모리 관리**: 페이지 테이블 수정, 메모리 보호 설정
- **인터럽트 제어**: 인터럽트 마스킹, 벡터 테이블 수정
- **특권 레지스터 접근**: 시스템 제어 레지스터

### 📋 커널 모드 (Kernel Mode)
- **최고 권한**: 모든 하드웨어와 시스템 자원에 접근 가능
- **특권 명령어**: 시스템 제어에 필요한 모든 명령어 실행 가능
- **운영체제 실행**: 커널과 시스템 서비스가 실행되는 모드
- **완전한 제어**: 메모리, I/O, 인터럽트 등 모든 시스템 자원 제어

#### 커널 모드에서만 가능한 작업
- **I/O 제어**: 하드웨어 직접 제어 및 드라이버 실행
- **메모리 관리**: 페이지 테이블 관리, 메모리 할당/해제
- **프로세스 관리**: 프로세스 생성, 종료, 스케줄링
- **시스템 호출 처리**: 사용자 요청에 대한 시스템 서비스 제공

### 📋 모드 전환 과정

#### 사용자 모드 → 커널 모드
1. **시스템 콜**: 사용자 프로그램이 시스템 서비스 요청
2. **인터럽트 발생**: 하드웨어 인터럽트 또는 예외 발생
3. **트랩**: 불법적인 명령어 실행 시도
4. **타이머 인터럽트**: 시분할 시스템의 시간 할당 만료

#### 커널 모드 → 사용자 모드
1. **시스템 콜 완료**: 요청된 서비스 처리 완료
2. **인터럽트 처리 완료**: 인터럽트 서비스 루틴 실행 완료
3. **프로세스 스케줄링**: 새로운 사용자 프로세스 선택
4. **예외 처리 완료**: 예외 상황 해결 후 복귀

### 📋 인터럽트와 모드 전환의 관계
- **자동 모드 전환**: 인터럽트 발생 시 자동으로 커널 모드로 전환
- **보안 검사**: 모드 전환 시 권한 및 유효성 검사
- **컨텍스트 저장**: 사용자 모드 상태 정보 저장
- **서비스 제공**: 커널 모드에서 시스템 서비스 제공 후 복귀

### 📋 하드웨어 지원
- **모드 비트**: CPU 내부의 모드 상태를 나타내는 플래그
- **특권 명령어**: 커널 모드에서만 실행 가능한 명령어
- **메모리 보호**: 사용자 모드에서 커널 영역 접근 차단
- **인터럽트 벡터**: 인터럽트 발생 시 커널 모드로 자동 전환

### 📋 실제 구현 예시
- **x86 아키텍처**: Ring 0(커널) ~ Ring 3(사용자) 보호 레벨
- **ARM 아키텍처**: User, Supervisor, IRQ, FIQ 등 다양한 모드
- **RISC-V**: User, Supervisor, Machine 모드
- **운영체제별**: Windows(커널/사용자), Linux(커널/사용자) 모드

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
<br>

## :book: `인터럽트와 이중 모드`에 대해 설명해주세요.
> 운영체제가 사용자/커널 모드를 전환하며 일 처리를 하는 것을 이중모드(Dual Mode)라고 합니다.

### 📋 이중 모드의 필요성
- **시스템 보호**: 사용자 프로그램이 시스템을 손상시키는 것을 방지
- **자원 관리**: 중요한 시스템 자원에 대한 접근 제어
- **안정성**: 하나의 프로그램 오류가 전체 시스템에 영향을 주지 않도록
- **보안**: 권한이 없는 작업의 실행 방지

### 📋 사용자 모드 (User Mode)
- **제한된 권한**: 일반적인 연산과 메모리 접근만 가능
- **직접 하드웨어 접근 불가**: I/O 장치, 특권 명령어 실행 불가
- **안전한 실행**: 시스템 안정성에 영향을 주지 않는 범위