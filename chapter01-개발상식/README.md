# 개발 상식

## 목차
1. [API와 SDK](#api와-sdk)
2. [객체 지향형 프로그래밍과 SOLID 원칙](#객체-지향형-프로그래밍과-solid-원칙)
3. [함수형 프로그래밍](#함수형-프로그래밍)
4. [순수 함수](#순수-함수)
5. [OOP vs FP 비교](#oop-vs-fp-비교)
6. [라이브러리 vs 프레임워크](#라이브러리-vs-프레임워크)
7. [Model1 vs Model2](#model1-vs-model2)
8. [디자인 패턴](#디자인-패턴)
9. [REST와 RESTful API](#rest와-restful-api)
10. [타이핑 시스템](#타이핑-시스템)
11. [개발 방법론](#개발-방법론)
12. [웹 개발 기초](#웹-개발-기초)
13. [성능 최적화](#성능-최적화)
14. [DevOps](#devops)
15. [동시성과 병렬성](#동시성과-병렬성)

---

## API와 SDK

### 📋 정의
- **API (Application Programming Interface)**: 응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스
- **SDK (Software Development Kit)**: API 및 API 사용 메뉴얼, 프로그램 개발에 필요한 코드 편집기와 에뮬레이터 등 각종 개발용 응용 프로그램까지 하나로 묶어 배포하는 개발 툴

### 📋 API 특징
- 시스템 호출보다 광범위한 개념
- 운영체제의 API를 시스템 호출이라고 할 수 있음
- 프로그램 간 통신을 위한 규칙과 명세를 정의

### 📋 SDK 특징
- 개발자를 위한 종합 선물 세트
- API + 개발 도구 + 문서 + 예제 코드
- 대표적인 예: Android Studio, Xcode

### 📋 실제 활용 예시
```
포토샵의 경우:
- 포토샵 자체는 얼굴 보정 필터를 내장하지 않음
- 대신 필터 개발자들을 위한 다양한 API를 제공
- 개발자들은 이 API를 통해 플러그인 형태로 기능 확장
```

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 객체 지향형 프로그래밍과 SOLID 원칙

### 📋 OOP 정의
**객체 지향형 프로그래밍(Object Oriented Programming)** 은 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결해 프로그래밍하는 기법입니다.

### 📋 OOP 4대 특징

#### 1️⃣ 캡슐화(Encapsulation)
- 객체의 내용 중 숨기고 싶은 부분을 외부에서 접근할 수 없게 감춤
- 정보의 은닉과 보호가 가능
- 데이터와 메서드를 하나의 단위로 묶음

#### 2️⃣ 추상화(Abstraction)
- 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법
- 복잡한 시스템을 단순화하여 표현
- 인터페이스와 추상 클래스를 통해 구현

#### 3️⃣ 다형성(Polymorphism)
- 코드의 재사용성이 증가되고 폭넓은 코드 구현이 가능
- 개발 속도를 향상시킬 수 있음
- 하나의 지시에 대해 여러 객체가 다른 행위를 수행
- **구현 방법**:
  - **오버로딩(Overloading)**: 같은 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의
  - **오버라이딩(Overriding)**: 부모 클래스의 메서드를 자식 클래스에서 재정의

#### 4️⃣ 상속성(Inheritance)
- 클래스의 멤버(데이터)와 함수를 다른 클래스에 물려주거나 물려받을 수 있는 기능
- 다형성을 확보할 수 있음
- 코드의 재사용성과 확장성을 제공

### 📋 SOLID 원칙

객체 지향 프로그래밍에서 권장되는 5가지 설계 원칙으로, 각 원칙의 앞 글자를 따서 **SOLID**라고 지칭합니다.

#### 1️⃣ SRP (Single Responsibility Principle) - 단일 책임 원칙
- **정의**: 모든 클래스는 단 하나의 책임을 가져야 함
- **핵심**: 클래스를 수정할 이유가 오직 하나여야 함
- **예시**: 계산기 클래스는 계산 기능과 GUI 표시 기능을 분리해야 함

```java
// ❌ SRP 위반
class Calculator {
    public int add(int a, int b) { return a + b; }
    public void displayGUI() { /* GUI 로직 */ }
}

// ✅ SRP 준수
class Calculator {
    public int add(int a, int b) { return a + b; }
}
class CalculatorView {
    public void displayGUI() { /* GUI 로직 */ }
}
```

#### 2️⃣ OCP (Open-Closed Principle) - 개방-폐쇄 원칙
- **정의**: 확장에 대해서는 개방되어 있어야 하지만, 수정에 대해서는 폐쇄되어야 함
- **핵심**: 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있어야 함
- **구현**: 추상화와 다형성을 활용

#### 3️⃣ LSP (Liskov Substitution Principle) - 리스코프 치환 원칙
- **정의**: 자식 클래스는 언제나 자신의 부모 클래스를 대신할 수 있어야 함
- **핵심**: 부모 클래스가 위치하는 자리에 자식 클래스를 대치해도 잘 작동해야 함
- **주의사항**: 상속 관계에서 일관성을 유지해야 함

#### 4️⃣ ISP (Interface Segregation Principle) - 인터페이스 분리 원칙
- **정의**: 클라이언트는 자신이 이용하지 않는 메서드에 의존하지 않아야 함
- **핵심**: 하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 나음
- **장점**: 인터페이스의 응집도를 높이고 결합도를 낮춤

#### 5️⃣ DIP (Dependency Inversion Principle) - 의존 역전 원칙
- **정의**: 상위 클래스는 하위 클래스에 의존해서는 안 됨
- **핵심**: 추상화에 의존해야 하며, 구체화에 의존하면 안 됨
- **구현**: 의존성 주입(Dependency Injection)을 통해 달성

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 함수형 프로그래밍

### 📋 정의
**함수형 프로그래밍(Functional Programming)** 은 기능을 순수 함수로 나누어 구현하는 기법으로, 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임입니다.

### 📋 핵심 개념

#### 1️⃣ 람다 대수 기반
- 계산 가능성, 결정 문제, 함수 정의, 함수 응용과 재귀를 연구하기 위해 개발된 체계
- 수학적 함수의 개념을 프로그래밍에 적용

#### 2️⃣ 참조 투명성(Referential Transparency)
- 같은 입력에 대해 항상 같은 출력을 보장
- 프로그램의 동작을 이해하고 예측하기 쉬움
- 부작용(Side Effect)을 효율적으로 제거

#### 3️⃣ 불변성(Immutability)
- 데이터를 변경하지 않고 새로운 데이터를 생성
- 상태 변경으로 인한 오류를 방지

### 📋 명령형 vs 함수형 프로그래밍

#### 명령형 프로그래밍의 문제점
- 명령형 함수는 프로그램의 상태를 변경시킬 수 있음
- 참조 투명성이 없어 같은 코드라도 실행 시점에 따라 다른 결과 발생 가능
- 디버깅과 테스트가 어려움

#### 함수형 프로그래밍의 장점
- 함수의 출력값이 입력된 인수에만 의존
- 부작용을 효율적으로 제거
- 프로그램의 동작을 이해하고 예측하기 쉬움
- 병렬 처리에 유리

### 📋 함수형 프로그래밍 특징

#### 고차 함수(Higher-Order Function)
- 함수를 인자로 받거나 함수를 반환하는 함수
- 함수의 조합을 통한 복잡한 로직 구현

#### 커링(Currying)
- 여러 개의 인자를 받는 함수를 하나의 인자를 받는 함수들의 체인으로 변환

#### 클로저(Closure)
- 함수와 그 함수가 선언된 렉시컬 환경의 조합

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 순수 함수

### 📋 정의
**순수 함수(Pure Function)** 는 같은 입력이 주어지면 항상 같은 출력을 반환하며, 부작용(Side Effect)이 존재하지 않는 함수입니다.

### 📋 순수 함수의 조건

#### 1️⃣ 동일한 입력에 대한 동일한 출력
```javascript
// ✅ 순수 함수
function add(a, b) {
  return a + b;
}

// ❌ 비순수 함수 (외부 변수 참조)
let multiplier = 2;
function multiply(a) {
  return a * multiplier; // 외부 변수에 의존
}
```

#### 2️⃣ 부작용(Side Effect) 없음
- 외부 상태를 변경하지 않음
- 전역 변수 수정 금지
- 파일 I/O, 네트워크 호출 등 외부 시스템과의 상호작용 금지

```javascript
// ❌ 부작용이 있는 함수
let count = 0;
function increment() {
  count++; // 외부 상태 변경
  return count;
}

// ✅ 순수 함수
function increment(count) {
  return count + 1; // 새로운 값 반환
}
```

### 📋 순수 함수의 장점

#### 1️⃣ 예측 가능성
- 동일한 입력에 대해 항상 동일한 결과
- 디버깅과 테스트가 용이

#### 2️⃣ 재사용성
- 외부 의존성이 없어 어디서든 사용 가능
- 모듈화가 쉬움

#### 3️⃣ 병렬 처리 안전성
- 상태를 변경하지 않아 동시성 문제 없음
- 멀티스레드 환경에서 안전

#### 4️⃣ 캐싱 가능
- 메모이제이션(Memoization) 적용 가능
- 성능 최적화에 유리

### 📋 순수 함수가 아닌 경우
```javascript
// ❌ 현재 시간에 의존
function getCurrentTime() {
  return new Date();
}

// ❌ 랜덤 값 생성
function getRandomNumber() {
  return Math.random();
}

// ❌ DOM 조작
function updateElement(id, text) {
  document.getElementById(id).textContent = text;
}
```

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## OOP vs FP 비교

### 📋 근본적인 차이점

#### 객체 지향 프로그래밍 (OOP)
- **중심**: 클래스와 객체의 관계
- **구성**: 상태(멤버 변수), 행위(메서드)가 긴밀하게 의존
- **특징**: 멤버 변수가 가진 상태에 따라 결과가 변함
- **장점**: 현실 세계의 모델링이 직관적

#### 함수형 프로그래밍 (FP)
- **중심**: 순수 함수와 보조 함수의 조합
- **구성**: 상태를 제어하는 복잡성을 최소화
- **특징**: 변수의 사용을 억제하여 상태 변경을 피함
- **장점**: 최적화된 동작과 예측 가능한 결과

### 📋 상세 비교

| 구분 | 객체 지향 프로그래밍 | 함수형 프로그래밍 |
|------|---------------------|------------------|
| **데이터 처리** | 객체의 상태 변경을 통한 처리 | 불변 데이터와 함수 조합을 통한 처리 |
| **코드 재사용** | 상속과 다형성을 통한 재사용 | 고차 함수와 함수 조합을 통한 재사용 |
| **상태 관리** | 객체 내부 상태를 캡슐화하여 관리 | 상태를 최소화하고 불변성 유지 |
| **디버깅** | 객체 상태 추적이 필요 | 함수별 독립적 테스트 가능 |
| **병렬 처리** | 동기화 메커니즘 필요 | 부작용이 없어 병렬 처리 용이 |

### 📋 언제 사용해야 할까?

#### OOP가 적합한 경우
- 복잡한 시스템의 모델링이 필요한 경우
- 사용자 인터페이스 개발
- 게임 개발 (엔티티, 컴포넌트 시스템)
- 대규모 애플리케이션의 구조화

#### FP가 적합한 경우
- 데이터 변환과 처리가 중심인 경우
- 수학적 계산이 많은 경우
- 병렬 처리가 중요한 경우
- 함수의 조합으로 복잡한 로직을 표현하는 경우

### 📋 현대적 접근: 다중 패러다임
현대의 많은 언어들은 OOP와 FP의 장점을 모두 활용하는 다중 패러다임을 지원합니다.

```javascript
// JavaScript에서 OOP + FP 혼합 사용
class DataProcessor {
  constructor(data) {
    this.data = data; // OOP: 캡슐화
  }
  
  // FP: 순수 함수들의 조합
  process() {
    return this.data
      .filter(item => item.isValid)
      .map(item => this.transform(item))
      .reduce((acc, item) => acc + item.value, 0);
  }
  
  transform(item) {
    return { ...item, processed: true }; // 불변성 유지
  }
}
```

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 라이브러리 vs 프레임워크

### 📋 근본적인 차이점

#### 라이브러리(Library)
- **정의**: 단순하게 활용 가능한 도구들의 집합으로 **개발자가 필요에 의해 만든 클래스를 호출하여 사용하는 방식**입니다.
- **특징**: 공통으로 사용될 수 있는 특정한 기능을 모듈화
- **사용자가 직접 실행할 수는 없음**
- **개발자가 라이브러리를 호출하여 제어권을 가짐**

#### 프레임워크(Framework)
- **정의**: **소프트웨어의 특정 문제를 해결하기 위해 상호간 의존하는 클래스와 인터페이스의 집합**으로, 애플리케이션의 골격을 제공합니다.
- **특징**: 완성된 애플리케이션이 아니므로 개발자가 완성시켜야 함
- **프레임워크가 제어권을 가지고 개발자 코드를 호출 (제어의 역전)**

### 📋 차이점
> 개발 주도성이 어디에 있는가?

#### 라이브러리
- 개발자가 프로세스를 작성하면서 필요한 코드를 가져다 사용하는 방식

#### 프레임워크
- 프로세스를 가지고 있으며 개발자가 필요한 코드를 작성함

### 📋 결론
> 라이브러리는 **개발자**에게, 프레임워크는 개발자가 아닌 **핵심 구조 안**에 프로세스에 대한 주도성이 담겨 있습니다.

### 📋 예시
- **jQuery**: DOM 조작을 위한 함수들의 집합
- **Lodash**: 유틸리티 함수들의 집합
- **Axios**: HTTP 클라이언트 라이브러리

```javascript
// 라이브러리 사용 예시 - jQuery
$('#button').click(function() {
  // 개발자가 필요할 때 jQuery 함수를 호출
  $('#content').hide();
});
```

### 📋 프레임워크 예시
- **React**: UI 개발을 위한 프레임워크
- **Spring**: Java 애플리케이션 개발 프레임워크
- **Django**: Python 웹 개발 프레임워크

```javascript
// 프레임워크 사용 예시 - React
function MyComponent() {
  // React가 이 함수를 언제 호출할지 결정
  return <div>Hello World</div>;
}
```

### 📋 핵심 차이점

#### 제어권의 위치 (Inversion of Control)
- **라이브러리**: 개발자가 라이브러리를 호출하여 제어권을 가짐
- **프레임워크**: 프레임워크가 개발자의 코드를 호출하여 제어권을 가짐

#### 사용 방식
- **라이브러리**: 필요한 기능을 선택적으로 가져다 사용
- **프레임워크**: 프레임워크가 정한 규칙과 구조를 따라 개발

#### 자유도
- **라이브러리**: 높은 자유도, 원하는 대로 조합 가능
- **프레임워크**: 상대적으로 낮은 자유도, 정해진 패턴을 따라야 함

### 📋 비교표

| 구분 | 라이브러리 | 프레임워크 |
|------|-----------|------------|
| **제어권** | 개발자 | 프레임워크 |
| **호출 관계** | 개발자 → 라이브러리 | 프레임워크 → 개발자 코드 |
| **자유도** | 높음 | 상대적으로 낮음 |
| **학습 곡선** | 완만함 | 상대적으로 가파름 |
| **구조** | 기능별 모듈 | 전체 애플리케이션 골격 |

### 📋 선택 기준

#### 라이브러리를 선택해야 하는 경우
- 특정 기능만 필요한 경우
- 기존 코드베이스에 최소한의 변경으로 기능을 추가하고 싶은 경우
- 높은 자유도와 유연성이 필요한 경우

#### 프레임워크를 선택해야 하는 경우
- 전체 애플리케이션을 새로 개발하는 경우
- 일관된 구조와 패턴이 필요한 경우
- 팀 개발에서 표준화된 개발 방식이 필요한 경우

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## Model1 vs Model2

### 📋 개요
웹 애플리케이션 개발에서 사용되는 두 가지 아키텍처 패턴으로, Model2는 Model1의 한계를 해결하기 위해 등장했습니다.

### 📋 Model1 아키텍처

<div align=center>

<img src="img/model1.jpg" alt="Model1" width="500"/>

**모든 클라이언트 요청과 응답을 JSP가 담당하는 구조**

</div>

#### 특징
- 페이지(View)에 비즈니스 로직과 결과 출력 코드가 혼재
- 해당 페이지에서 모든 정보를 저장(Model)하거나 처리(Controller)
- 단순한 구조로 빠른 개발 가능

#### 장점
- **개발 용이성**: 단순한 페이지 작성으로 구현이 쉬움
- **소규모 프로젝트 적합**: 빠른 프로토타이핑 가능
- **학습 곡선**: 초보자도 쉽게 이해 가능

#### 단점
- **재사용성 부족**: 코드 중복이 많이 발생
- **가독성 저하**: 비즈니스 로직과 뷰가 혼재
- **유지보수 어려움**: 대규모 애플리케이션에서 복잡도 증가
- **역할 분리 미흡**: 개발자 간 업무 분담이 어려움

### 📋 Model2 아키텍처

<div align=center>

<img src="img/model2.jpg" alt="Model2" width="500"/>

**클라이언트의 요청, 응답, 비즈니스 로직 처리 부분을 모듈화한 구조**

</div>

#### 특징
- MVC 패턴의 기본적인 구조
- 클라이언트 요청을 하나의 Web Container가 받아 처리
- Model, View, Controller의 명확한 역할 분리

#### 장점
- **역할 분리**: 각 컴포넌트의 책임이 명확
- **유지보수성**: 처리 작업의 분리로 유지보수 용이
- **확장성**: 새로운 기능 추가가 쉬움
- **재사용성**: 컴포넌트 단위로 재사용 가능
- **팀 개발**: 역할별 병렬 개발 가능

#### 단점
- **초기 설계 복잡**: 구조 설계를 위한 시간 소요
- **개발 시간 증가**: 초기 개발 시간이 상대적으로 길어짐
- **학습 곡선**: 아키텍처 이해가 필요

### 📋 구조 비교

#### Model1 흐름
```
Client → JSP (View + Controller + Model) → Database
       ← JSP (Response) ←
```

#### Model2 흐름
```
Client → Controller → Model → Database
       ← View ← Controller ←
```

### 📋 선택 기준

#### Model1을 선택하는 경우
- 소규모 프로젝트
- 빠른 프로토타이핑이 필요한 경우
- 단순한 기능의 웹 애플리케이션
- 학습 목적의 프로젝트

#### Model2를 선택하는 경우
- 중대규모 프로젝트
- 장기적인 유지보수가 필요한 경우
- 팀 단위의 개발 프로젝트
- 확장 가능성을 고려해야 하는 경우

### 📋 현대적 발전
Model2 아키텍처는 현재 다양한 형태로 발전했습니다:
- **MVC 프레임워크**: Spring MVC, ASP.NET MVC
- **MVP 패턴**: 테스트 용이성을 개선
- **MVVM 패턴**: 데이터 바인딩으로 뷰와 로직 분리
- **Component 기반**: React, Vue.js 등의 컴포넌트 아키텍처

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 디자인 패턴

### 📋 MVC 패턴 (Model-View-Controller)

<div align=center>

<img src="img/mvc.jpg" alt="MVC Pattern" width="500"/>

</div>

#### 정의
소프트웨어 디자인 패턴으로 **Model–View–Controller**의 약자입니다. UI(View)로부터 비즈니스 로직(Model, Controller)을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 기능을 영향 없이 쉽게 고칠 수 있습니다.

#### 구성 요소

##### 1️⃣ Model (모델)
- **역할**: 애플리케이션의 정보(데이터)와 비즈니스 로직을 담당
- **특징**: 
  - 상태가 변경되면 Controller와 View에 통보
  - 데이터베이스, API, 파일 시스템 등과 연동
  - View나 Controller에 대한 의존성이 없어야 함

##### 2️⃣ View (뷰)
- **역할**: 사용자 인터페이스(UI) 요소를 담당
- **특징**:
  - 사용자가 볼 결과물을 표현
  - Model로부터 정보를 가져와 화면에 표시
  - 사용자 입력을 Controller에 전달

##### 3️⃣ Controller (컨트롤러)
- **역할**: 데이터와 비즈니스 로직 사이의 상호작용을 관리
- **특징**:
  - Model에 명령하여 상태를 변경
  - View에 명령하여 Model의 표현 방식을 변경
  - 사용자 입력을 받아 Model과 View를 업데이트

#### 동작 흐름
```
1. 사용자가 View를 통해 입력
2. Controller가 입력을 받아 Model에 전달
3. Model이 데이터를 처리하고 상태 변경
4. Model이 Controller에 변경사항 통보
5. Controller가 View에 업데이트 명령
6. View가 업데이트된 데이터를 사용자에게 표시
```

#### 장점
- **분리된 관심사**: 각 컴포넌트의 역할이 명확히 분리
- **재사용성**: 컴포넌트별로 독립적인 재사용 가능
- **유지보수성**: 한 부분의 수정이 다른 부분에 미치는 영향 최소화
- **병렬 개발**: 각 컴포넌트를 독립적으로 개발 가능

#### 단점
- **복잡성 증가**: 작은 애플리케이션에서는 과도한 구조화
- **의존성**: Controller가 View와 Model 모두에 의존

### 📋 MVP 패턴 (Model-View-Presenter)

<div align=center>

<img src="img/mvp.png" alt="MVP Pattern" width="500"/>

</div>

#### 정의
MVC가 가진 **Model-View-Controller 사이의 강한 결합을 해결**하기 위해 등장한 소프트웨어 디자인 패턴으로, Model-View-Presenter의 약자입니다.

#### 구성 요소

##### 1️⃣ Model (모델)
- MVC의 Model과 동일한 역할
- 데이터와 비즈니스 로직을 담당

##### 2️⃣ View (뷰)
- **특징**: UI를 표현하며 사용자 정보의 입/출력만을 담당
- **제약**: 비즈니스 로직을 포함하지 않음
- **수동적 역할**: Presenter의 지시에 따라서만 동작

##### 3️⃣ Presenter (프레젠터)
- **역할**: View로부터 입력을 받아 Model에 요청하고, Model의 응답으로 View를 갱신
- **특징**: View와 1:1 관계를 가짐

#### 동작 흐름
```
1. View가 사용자 입력을 Presenter에 전달
2. Presenter가 Model에 데이터 요청
3. Model이 데이터를 찾아 Presenter에 응답
4. Presenter가 View에 응답 전달
5. View가 최종 응답 데이터로 화면 갱신
```

#### 장점
- **테스트 용이성**: View가 인터페이스로 추상화되어 단위 테스트가 쉬움
- **명확한 역할 분리**: 각 컴포넌트의 책임이 더욱 명확

#### 단점
- **강한 결합**: View와 Presenter가 1:1로 강하게 결합
- **복잡성**: Presenter에 로직이 집중되어 복잡해질 수 있음

### 📋 MVVM 패턴 (Model-View-ViewModel)

<div align=center>

<img src="img/mvvm.png" alt="MVVM Pattern" width="500"/>

</div>

#### 정의
MVP가 가진 **View-Presenter의 강한 결합을 해결**하기 위해 등장한 소프트웨어 디자인 패턴으로, Model-View-View Model의 약자입니다.

#### 구성 요소

##### 1️⃣ Model (모델)
- 기존 패턴들과 동일한 역할
- 데이터와 비즈니스 로직을 담당

##### 2️⃣ View (뷰)
- 사용자 인터페이스를 담당
- ViewModel의 데이터를 관찰하여 자동으로 업데이트

##### 3️⃣ ViewModel (뷰모델)
- **역할**: View와 Model 사이의 바인딩을 담당
- **특징**: 데이터를 제공하며, View는 ViewModel의 데이터로 UI를 갱신
- **데이터 바인딩**: View와 양방향 데이터 바인딩을 통해 자동 동기화

#### 동작 흐름
```
1. View가 ViewModel에 이벤트(사용자 입력) 전달
2. ViewModel이 Model에 데이터 요청
3. Model이 ViewModel에 응답하여 데이터 전송
4. ViewModel이 데이터를 가공하여 저장
5. View가 ViewModel의 데이터 변경을 감지하여 자동 업데이트
```

#### 핵심 개념: 데이터 바인딩
- **양방향 데이터 바인딩**: View의 변경사항이 ViewModel에 자동 반영되고, 그 역도 성립
- **Observer 패턴**: 데이터 변경을 자동으로 감지하고 반영

#### 장점
- **낮은 결합도**: Model, View, ViewModel 사이의 의존성이 매우 낮음
- **TDD 친화적**: 테스트 주도 개발과 유지보수가 매우 쉬움
- **자동 동기화**: 데이터 바인딩으로 수동 업데이트 코드 불필요

#### 단점
- **복잡한 데이터 바인딩**: 복잡한 UI에서는 바인딩 로직이 복잡해질 수 있음
- **메모리 사용량**: 바인딩 메커니즘으로 인한 추가 메모리 사용

#### 적용 분야
- **React**: State와 Props를 통한 데이터 바인딩
- **Vue.js**: 반응형 데이터 시스템
- **Angular**: Two-way data binding
- **WPF**: .NET의 데이터 바인딩

### 📋 Flux 패턴

<div align=center>

<img src="img/flux.png" alt="Flux Pattern" width="500"/>

</div>

#### 배경
MVC 패턴은 **양방향 데이터 흐름**을 만들어 예측하기 어려운 버그를 발생시킵니다. 특히 대규모 애플리케이션에서는 데이터의 흐름을 추적하기 어려워집니다.

#### 핵심 특징: 단방향 데이터 흐름
Flux의 가장 큰 특징은 **단방향 데이터 흐름(Unidirectional Data Flow)**입니다.

#### 구성 요소

##### 1️⃣ Action (액션)
- **역할**: 애플리케이션에서 발생하는 모든 변경 사항을 나타내는 객체
- **특징**: 타입(type)과 데이터(payload)를 포함

##### 2️⃣ Dispatcher (디스패처)
- **역할**: 액션을 받아서 등록된 콜백 함수들에게 전달
- **특징**: 중앙 집중식 허브 역할

##### 3️⃣ Store (스토어)
- **역할**: 애플리케이션의 상태와 로직을 보관
- **특징**: Dispatcher에 콜백을 등록하여 액션에 반응

##### 4️⃣ View (뷰)
- **역할**: Store의 상태를 표시하고 사용자 입력을 Action으로 변환
- **특징**: Store의 변경사항을 구독하여 자동 업데이트

#### 동작 흐름
```
Action → Dispatcher → Store → View
  ↑                           ↓
  ←←←←←←← User Interaction ←←←←←
```

1. 이벤트(action)가 발생하면 Dispatcher로 전달
2. Dispatcher는 등록된 Callback 함수를 실행하고, Store에 데이터를 전달
3. Store는 변경된 데이터를 View에 알림
4. View는 변경된 데이터로 화면을 변경하거나 출력

#### 장점
- **예측 가능성**: 단방향 데이터 흐름으로 데이터 변경 추적이 쉬움
- **디버깅 용이성**: 액션을 통해 모든 상태 변경을 추적 가능
- **확장성**: 대규모 애플리케이션에서 상태 관리가 용이

#### 단점
- **보일러플레이트**: 단순한 기능도 많은 코드가 필요
- **학습 곡선**: 개념 이해에 시간이 필요

#### 관련 기술
- **Redux**: Flux 패턴을 구현한 상태 관리 라이브러리
- **MobX**: Observer 패턴을 활용한 상태 관리
- **Vuex**: Vue.js를 위한 Flux 패턴 구현

### 📋 패턴 비교 요약

| 패턴 | 주요 특징 | 장점 | 단점 | 적용 분야 |
|------|----------|------|------|----------|
| **MVC** | Controller 중심의 3계층 구조 | 역할 분리, 재사용성 | Controller 의존성 | 전통적 웹 애플리케이션 |
| **MVP** | Presenter가 View와 1:1 매핑 | 테스트 용이성 | View-Presenter 강한 결합 | 데스크톱 애플리케이션 |
| **MVVM** | 데이터 바인딩 중심 | 낮은 결합도, 자동 동기화 | 복잡한 바인딩 | 모던 프론트엔드 |
| **Flux** | 단방향 데이터 흐름 | 예측 가능성, 디버깅 용이 | 보일러플레이트 코드 | 대규모 SPA |

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## REST와 RESTful API

### 📋 REST 정의
**REST(Representational State Transfer)** 는 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일입니다. 최근의 서버 프로그램은 다양한 브라우저와 모바일 디바이스에서도 통신을 할 수 있어야 하며, REST 아키텍처는 이러한 Hypermedia API의 기본을 충실히 지키고 범용성을 보장합니다.

#### 핵심 구성 요소
REST는 **자원(Resource : URI)**, **행위(Verb : HTTP Method)**, **표현(Representations)** 으로 구성됩니다.

### 📋 REST 제약 조건 (6가지)

#### 1️⃣ 클라이언트-서버 구조 (Client-Server Architecture)
- **정의**: UI에 대한 관심(Concern)을 데이터에 대한 관심으로부터 분리
- **장점**: 
  - 클라이언트의 이식성 향상
  - 서버의 규모 확장성 향상
  - 각각 독립적으로 발전 가능

#### 2️⃣ 무상태성 (Stateless)
- **정의**: 클라이언트와 서버의 통신에는 상태가 없어야 하며, 모든 요청은 필요한 모든 정보를 포함해야 함
- **장점**:
  - **가시성**: 요청 하나만 봐도 바로 무엇인지 알 수 있음
  - **신뢰성**: Task 실패 시 복원이 쉬움
  - **확장성**: 상태를 저장할 필요가 없어 규모 확장에 용이
  - **단순성**: 메시지로만 처리하므로 구현이 단순

#### 3️⃣ 캐시 처리 가능 (Cacheable)
- **정의**: 모든 서버 응답은 캐시 처리 가능 여부를 명시해야 함
- **장점**: 효율성, 규모 확장성, 사용자 경험 향상
- **구현**: Cache-Control, ETag 등의 HTTP 헤더 활용

#### 4️⃣ 유니폼 인터페이스 (Uniform Interface)
- **정의**: 구성요소(클라이언트, 서버 등) 사이의 인터페이스는 균일해야 함
- **4가지 제약조건**:
  - **자원 식별**: URI로 자원을 고유하게 식별
  - **표현을 통한 자원 조작**: HTTP 메서드로 자원 조작
  - **자기 서술적 메시지**: 메시지 자체로 의미 전달
  - **HATEOAS**: 애플리케이션 상태의 엔진으로서 하이퍼미디어
- **장점**: 전체 시스템 아키텍처 단순화, 상호작용 가시성 개선

#### 5️⃣ 계층형 구조 (Layered System)
- **정의**: 계층(Hierarchical layers)으로 구성되어야 함
- **특징**: 각 계층에 속한 구성요소는 인접하지 않은 계층의 구성요소를 볼 수 없음
- **예시**: Client → CDN → Load Balancer → API Gateway → Server

#### 6️⃣ Code-On-Demand (선택사항)
- **정의**: 클라이언트의 요청에 따라 서버에서 클라이언트로 실행 가능한 소프트웨어 전달
- **특징**: 유일한 선택적 제약조건
- **예시**: JavaScript, Java Applet

### 📋 HTTP 메서드와 REST

| HTTP 메서드 | 의미 | 멱등성 | 안전성 | 용도 |
|-------------|------|--------|--------|------|
| **GET** | 조회 | ✅ | ✅ | 리소스 조회 |
| **POST** | 생성/처리 | ❌ | ❌ | 리소스 생성, 데이터 처리 |
| **PUT** | 전체 수정 | ✅ | ❌ | 리소스 전체 교체 |
| **PATCH** | 부분 수정 | ❌ | ❌ | 리소스 부분 수정 |
| **DELETE** | 삭제 | ✅ | ❌ | 리소스 삭제 |

### 📋 RESTful API 설계 원칙

#### 1️⃣ 자원과 행위의 분리
- **자원(Resource)**: URI로 표현
- **행위(Verb)**: HTTP Method로 표현

```http
# ✅ 좋은 예시
GET    /users/123        # 사용자 조회
POST   /users            # 사용자 생성
PUT    /users/123        # 사용자 전체 수정
DELETE /users/123        # 사용자 삭제

# ❌ 나쁜 예시
GET    /getUser?id=123   # 동사 사용
POST   /createUser       # 동사 사용
POST   /deleteUser       # HTTP 메서드와 의미 불일치
```

#### 2️⃣ URI 설계 규칙

##### 명사 사용, 동사 금지
```http
# ✅ 좋은 예시
/users
/orders
/products

# ❌ 나쁜 예시
/getUsers
/createOrder
/deleteProduct
```

##### 복수형 사용
```http
# ✅ 좋은 예시
/users/123
/orders/456

# ❌ 나쁜 예시
/user/123
/order/456
```

##### 계층 관계 표현
```http
# ✅ 계층 관계
/users/123/orders          # 특정 사용자의 주문 목록
/users/123/orders/456      # 특정 사용자의 특정 주문
```

##### 소문자 사용, 하이픈(-) 사용
```http
# ✅ 좋은 예시
/user-profiles
/order-items

# ❌ 나쁜 예시
/userProfiles
/User_Profiles
/OrderItems
```

#### 3️⃣ 상태 코드 활용

| 상태 코드 | 의미 | 용도 |
|-----------|------|------|
| **200** | OK | 성공적인 GET, PUT, PATCH |
| **201** | Created | 성공적인 POST |
| **204** | No Content | 성공적인 DELETE |
| **400** | Bad Request | 잘못된 요청 |
| **401** | Unauthorized | 인증 실패 |
| **403** | Forbidden | 권한 없음 |
| **404** | Not Found | 리소스 없음 |
| **409** | Conflict | 리소스 충돌 |
| **500** | Internal Server Error | 서버 오류 |

#### 4️⃣ 페이지네이션
```http
GET /users?page=1&limit=20&sort=created_at&order=desc
```

#### 5️⃣ 필터링과 검색
```http
GET /users?status=active&role=admin
GET /products?category=electronics&price_min=100&price_max=500
```

### 📋 RESTful API 예시

#### 할일 관리 API
```http
# 할일 목록 조회
GET /todos

# 특정 할일 조회
GET /todos/123

# 할일 생성
POST /todos
Content-Type: application/json
{
  "title": "회의 준비",
  "description": "팀 회의를 위한 자료 준비",
  "due_date": "2023-12-31"
}

# 할일 수정
PUT /todos/123
Content-Type: application/json
{
  "title": "회의 준비 완료",
  "completed": true
}

# 할일 삭제
DELETE /todos/123

# 할일의 하위 항목들
GET /todos/123/items
POST /todos/123/items
PUT /todos/123/items/456
DELETE /todos/123/items/456
```

### 📋 REST의 장단점

#### 장점
- **개방성**: Open API 제공이 쉬움
- **멀티 플랫폼**: 다양한 플랫폼에서 동일한 API 사용 가능
- **유연성**: 원하는 타입으로 데이터 송수신 가능 (JSON, XML 등)
- **웹 표준 활용**: 기존 웹 인프라(HTTP) 활용으로 별도 인프라 불필요
- **캐싱**: HTTP 캐싱 메커니즘 활용 가능

#### 단점
- **HTTP 메서드 제한**: 사용할 수 있는 HTTP Method가 제한적
- **분산환경 부적합**: 분산 트랜잭션 처리가 어려움
- **HTTP 의존성**: HTTP 통신 모델에만 의존
- **표준 부족**: 명확한 표준이 없어 설계자에 따라 차이 발생

### 📋 REST vs GraphQL vs gRPC

| 특성 | REST | GraphQL | gRPC |
|------|------|---------|------|
| **데이터 fetching** | 여러 요청 필요할 수 있음 | 단일 요청으로 필요한 데이터만 | 강타입 스키마 기반 |
| **캐싱** | HTTP 캐싱 활용 용이 | 복잡한 캐싱 전략 필요 | 구현에 따라 다름 |
| **학습 곡선** | 낮음 | 중간 | 높음 |
| **성능** | 네트워크 오버헤드 있을 수 있음 | 필요한 데이터만 전송 | 높은 성능 (바이너리) |
| **도구 지원** | 광범위함 | 증가하고 있음 | 제한적이지만 성장 중 |

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 타이핑 시스템

### 📋 정적 타이핑 vs 동적 타이핑

#### 정의
- **정적 타입 언어**: 변수에 할당할 수 있는 타입을 미리 지정해야 하는 언어 (명시적 타입 선언)
- **동적 타입 언어**: 변수를 선언할 때 타입을 선언하지 않는 언어 (암시적 타입 선언)

### 📋 정적 타입 언어

#### 특징
- **타입 불변성**: 변수의 타입을 변경할 수 없어 선언한 타입에 맞는 값만 할당 가능
- **컴파일 시점 검사**: 컴파일 시점에 타입을 체크하여 런타임 오류를 사전에 방지

#### 예시 코드
```java
// Java
int age = 25;
String name = "John";
age = name;  // ❌ 컴파일 에러: 타입 불일치
```

```typescript
// TypeScript
let count: number = 10;
let message: string = "Hello";
count = message;  // ❌ 타입 에러
```

#### 장점
- **안정성**: 타입 일관성을 강제하여 안정적인 코드 구현
- **런타임 오류 감소**: 컴파일 시점에 타입 관련 오류를 방지
- **IDE 지원**: 자동완성, 리팩토링 등 개발 도구 지원이 우수
- **성능**: 컴파일 시점에 최적화 가능

#### 단점
- **개발 속도**: 초기 개발 시 타입 정의로 인한 속도 저하
- **학습 곡선**: 타입 시스템에 대한 이해 필요
- **유연성 제한**: 동적인 프로그래밍 패턴 구현이 어려울 수 있음

### 📋 동적 타입 언어

#### 특징
- **타입 자유도**: 어떤 타입이라도 자유롭게 할당 가능
- **런타임 타입 결정**: 선언이 아닌 할당에 의해 타입이 결정 (타입 추론)

#### 예시 코드
```javascript
// JavaScript
let value = 10;        // number
value = "Hello";       // string
value = true;          // boolean
value = [1, 2, 3];     // array
```

```python
# Python
a = 0
a = "text"
a = [1, 2, 3]
```

#### 장점
- **개발 속도**: 빠른 프로토타이핑과 개발 가능
- **유연성**: 다양한 프로그래밍 패턴 구현 용이
- **간결함**: 타입 선언 없이 간결한 코드 작성

#### 단점
- **런타임 오류**: 타입 관련 오류가 런타임에 발생 가능
- **예측 불가능성**: 코드의 동작을 예측하기 어려울 수 있음
- **디버깅 어려움**: 타입 관련 버그 추적이 어려움

### 📋 암묵적 타입 변환 (Type Coercion)

JavaScript와 같은 동적 타입 언어에서는 엔진에 의해 **암묵적으로 타입이 자동 변환**되기도 합니다.

#### 예시
```javascript
// JavaScript 암묵적 타입 변환
let result1 = "5" + 3;      // "53" (숫자 → 문자열)
let result2 = "5" - 3;      // 2 (문자열 → 숫자)
let result3 = "5" * "2";    // 10 (문자열 → 숫자)
let result4 = true + 1;     // 2 (불린 → 숫자)

// 예상치 못한 결과
console.log([] + []);       // "" (빈 문자열)
console.log({} + {});       // "[object Object][object Object]"
```

#### 문제점
- **예측 불가능성**: 개발자의 의도와 다른 결과 발생 가능
- **디버깅 어려움**: 어디서 타입 변환이 일어났는지 추적하기 어려움
- **신뢰성 저하**: 유연성은 높지만 신뢰성은 떨어짐

### 📋 점진적 타입 시스템 (Gradual Typing)

#### TypeScript
JavaScript의 문제점을 해결하기 위해 등장한 **점진적 타입 시스템**:

```typescript
// 점진적으로 타입을 추가할 수 있음
let data: any = getData();        // any 타입으로 시작
let user: User = data as User;    // 타입 어설션
let name: string = user.name;     // 엄격한 타입 체크
```

#### 특징
- **점진적 적용**: 기존 JavaScript 코드에 점진적으로 타입 추가 가능
- **타입 추론**: 명시하지 않은 타입도 추론하여 타입 안전성 제공
- **컴파일 타임 체크**: 개발 시점에 타입 오류 발견

### 📋 타입 시스템 비교

| 특성 | 정적 타입 | 동적 타입 | 점진적 타입 |
|------|-----------|-----------|-------------|
| **타입 선언** | 필수 | 불필요 | 선택적 |
| **타입 체크 시점** | 컴파일 타임 | 런타임 | 컴파일 타임 |
| **개발 속도** | 느림 (초기) | 빠름 | 중간 |
| **안정성** | 높음 | 낮음 | 높음 |
| **유연성** | 낮음 | 높음 | 높음 |
| **IDE 지원** | 우수 | 제한적 | 우수 |
| **런타임 성능** | 우수 | 보통 | 우수 |

### 📋 선택 기준

#### 정적 타입을 선택해야 하는 경우
- **대규모 프로젝트**: 많은 개발자가 참여하는 프로젝트
- **장기 유지보수**: 오랜 기간 유지보수가 필요한 시스템
- **안정성 중시**: 오류가 치명적인 시스템 (금융, 의료 등)
- **팀 개발**: 코드의 일관성과 예측 가능성이 중요한 경우

#### 동적 타입을 선택해야 하는 경우
- **프로토타이핑**: 빠른 아이디어 검증이 필요한 경우
- **소규모 프로젝트**: 간단하고 빠른 개발이 우선인 경우
- **스크립트 작성**: 간단한 자동화나 데이터 처리 스크립트
- **유연성 요구**: 메타프로그래밍이나 동적 기능이 필요한 경우

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 개발 방법론

### 📋 TDD (Test-Driven Development)

<div align=center>

<img src="img/tdd.jpg" alt="TDD" width="500"/>

</div>

#### 정의
TDD는 테스트를 중심으로 개발하는 방법론으로, 테스트 케이스를 먼저 작성하고 이를 통과하는 코드를 작성하는 방식입니다.

#### 장점
- **빠른 피드백**: 테스트를 통해 빠르게 피드백 받을 수 있음
- **안정성**: 테스트를 통해 코드의 안정성을 보장
- **설계 개선**: 테스트를 통해 설계를 개선할 수 있음

#### 단점
- **초기 개발 시간 증가**: 테스트 케이스 작성에 추가 시간 필요
- **학습 곡선**: 테스트 작성에 대한 이해 필요

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 웹 개발 기초

### 📋 웹 개발의 기본 요소
- HTML, CSS, JavaScript
- 서버 사이드 프로그래밍 언어 (Node.js, Python, PHP 등)
- 데이터베이스와의 연동
- 웹 표준과 접근성

### 📋 웹 개발 프로세스
1. 기획
2. 디자인
3. 퍼블리싱
4. 프로그램 개발
5. 테스트/검수
6. 홍보 및 마케팅

<br>

> 참조
> - [홈페이지 제작 과정](https://homepage-academy.blogspot.com/2019/09/homepage-production-process.html)

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 성능 최적화

### 📋 정의
성능 최적화는 소프트웨어의 성능을 향상시키는 프로세스입니다.

### 📋 방법

#### 1️⃣ 캐시 사용
- 자주 사용되는 데이터를 메모리에 저장하여 빠른 접근 가능

#### 2️⃣ 데이터베이스 최적화
- 쿼리 최적화, 인덱스 사용, 트랜잭션 관리

#### 3️⃣ 서버 최적화
- 분산 시스템 설계, 데이터베이스 분산, 로드밸런싱

#### 4️⃣ 프론트엔드 최적화
- 코드 분할, 이미지 최적화, 브라우저 캐시 활용

### 📋 도구
- 퍼포먼스 툴 (Chrome DevTools, WebPageTest)
- 코드 분석 도구 (JProfiler, VisualVM)
- 모니터링 도구 (Prometheus, Grafana)

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## DevOps

### 📋 정의
DevOps는 개발(Development)과 운영(Operations)을 통합하는 문화와 프로세스입니다.

### 📋 중요한 개념

#### 1️⃣ 지속적인 통합(CI)
- 코드 변경 사항을 자동으로 빌드하고 테스트하는 프로세스

#### 2️⃣ 지속적인 제공(CD)
- 애플리케이션에 변경 사항을 지속적으로 제공하는 프로세스

### 📋 장점
- 빠른 피드백과 지속적인 개선
- 높은 품질과 안정성
- 빠른 시장 진입

### 📋 구성요소
- 지속적인 통합 플랫폼 (Jenkins, GitLab CI)
- 컨테이너 플랫폼 (Docker, Kubernetes)
- 인프라 자동화 도구 (Ansible, Terraform)
- 모니터링 도구 (Prometheus, Grafana)

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>

## 동시성과 병렬성

### 📋 정의
동시성은 동시에 둘 이상의 작업이 실행되는 것입니다. 병렬성은 작업이 동시에 병렬적으로 실행된다는 것입니다.

### 📋 차이점
동시성은 작업이 동시에 수행될 필요는 없으나 가능하다는 것입니다. 병렬성은 작업이 동시에 병렬적으로 실행된다는 것입니다.

### 📋 중요성
- 높은 성능과 확장성을 위해 필요
- 복잡한 시스템을 단순화하는 방법

<br>

<sup>[(상위 문서로)](https://github.com/InSeong-So/IT-Note)</sup>

<hr>
